<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Howshea</title>
  
  <subtitle>心里像是有一些话，我们先不讲</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://howshea.coding.me/"/>
  <updated>2019-06-10T14:38:19.919Z</updated>
  <id>https://howshea.coding.me/</id>
  
  <author>
    <name>Howshea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>与死神擦肩而过的第24个小时</title>
    <link href="https://howshea.coding.me/2019/06/10/%E4%B8%8E%E6%AD%BB%E7%A5%9E%E6%93%A6%E8%82%A9%E8%80%8C%E8%BF%87%E7%9A%84%E7%AC%AC24%E4%B8%AA%E5%B0%8F%E6%97%B6/"/>
    <id>https://howshea.coding.me/2019/06/10/与死神擦肩而过的第24个小时/</id>
    <published>2019-06-10T13:51:16.000Z</published>
    <updated>2019-06-10T14:38:19.919Z</updated>
    
    <content type="html"><![CDATA[<p>我还活着</p><a id="more"></a><p>昨天下午从合肥回到杭州之后，下了地铁在路边找了一辆共享单车准备开开心心骑回家，骑到最后一个路口，离小区已经不到300米了，一个没有红绿灯的三岔路口，我没走过这条路，完全是靠导航走到了这里。对于没有红绿灯的路口，我完全没有经验，车辆来往不息，我等了一会终于找到一个间隙，那辆车离我有些距离，根据以往的经验，他只要稍微减一下速，我百分之百是可以过去的，人行道就在他前面，哪怕没有行人，他也会稍微减下速吧，那一瞬间我是这么想的。</p><p>想法是美好的，可惜我大脑里对过马路的认知模型里，没有汽车过人行道不减速甚至还在加速这一条特殊情况。当我开始过马路时，余光发现那辆车竟然好像没有看见我一样，加速冲了过来，我下意识捏住刹车，一瞬间心里想的只有：”你为什么要加速撞我”，随即砰的一下，我飞起来了。</p><p>人在要死的时候会想什么？腾空的零点几秒里我没有时间想那么多，脑子里闪过”我要死了吗”这么简单的一句，然后就重重地摔在了地上，摔下去之后我应该还滑了一小段，大脑短暂空白恢复之后，我发现自己半蜷缩着侧躺在地上，头枕在了我的右臂上，我还有意识！我没死！虽然整个人已经疼的麻掉，我还是尝试感受了一下各个器官和骨头的情况，才发现刚才万幸的是，我没有被直接撞到，轿车撞到了单车的车头，所以我受到的所有伤害都来源于摔伤，如果当时我没有及时停下，就差一步，我可能就要去见上帝了。</p><p>接着是听到有人问我怎么样，我睁开眼，看到撞我的车停在旁边，车主下来蹲在我身边，我让他把我的眼镜找到，作为一个700度近视的人，我需要确认我的眼镜是否完好，所幸眼镜找回来了，也没有破碎和形变。然后就是被拉起来，车主送我去医院、拍CT、清理伤口、叫保险公司、叫交警定责，然后被送回家。</p><p>我的手机钢化膜整块全碎，但是屏幕完好，这台XR替我的大腿挡住了所有伤害。右臂的外套完全破了，整个手臂都是磨破的皮肤，以至于我现在睡觉变得很困难，实在太疼了。右脚的两侧脚踝都磨破肿了起来，不知道是怎么伤到的，也许我在地上还翻滚了两圈。</p><p>昨天其他部位还没什么感觉，今天早上起床才发现我只能靠手臂把自己撑起来，脖子能转动，但是一圈肌肉一用力就很痛，腹肌也是很痛无法用力，像是练了一百个仰卧起坐，腰背的肌肉情况相比好一些，能正常用力。我才意识到昨天我的身体为了保护自己，发挥了多大的潜能，为了维持一个安全的姿势落地和头部的安全，强行超负荷调动了全身的肌肉，所谓的嘴上这么说身体却很诚实，大概就是这么回事，以为自己要嗝屁了，身体不让。所以我现在才能安稳地坐在书桌前正常写字，喝着续命的冷萃咖啡。</p><p>现在是5点半，刚好是昨天事故发生的时候，一切都还好。车祸发生之后我跟两个朋友说了情况，一个朋友全程告诉我交通事故怎么处理、怎么检查身体，另一个朋友听闻我无大碍，给我寄了一个”御守”（虽然我不知道这是什么，听起来像是龟壳保平安的），感谢他们的关心。</p><p>以后过马路会尽量绕开没有红绿灯且人流量少的路口，不要相信任何车辆会减速，赌不起。以及，活着真好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我还活着&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://howshea.coding.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="个人日记" scheme="https://howshea.coding.me/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>理解 Kotlin 中的属性（property）</title>
    <link href="https://howshea.coding.me/2019/04/22/%E7%90%86%E8%A7%A3-Kotlin-%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%88property%EF%BC%89/"/>
    <id>https://howshea.coding.me/2019/04/22/理解-Kotlin-中的属性（property）/</id>
    <published>2019-04-22T03:20:23.000Z</published>
    <updated>2019-09-12T08:23:22.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章是一时兴起想写的，因为我发现我对Kotlin的属性理解一直有误</p></blockquote><a id="more"></a><h2 id="Java-中的属性是什么（property）"><a href="#Java-中的属性是什么（property）" class="headerlink" title="Java 中的属性是什么（property）"></a>Java 中的属性是什么（property）</h2><p>首先我们要搞清楚在 Java 中属性是什么，在 Java 中类的属性不是指一个字段，而是一个字段和它的get、set方法加在一起才算一个属性，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果不给这个 name 写get、set方法，它就只是一个 <strong>field</strong>,可以称它为 <strong>字段</strong> 或者 <strong>域</strong>。</p><h2 id="Kotlin的类只有属性（property）没有独立的字段（field）"><a href="#Kotlin的类只有属性（property）没有独立的字段（field）" class="headerlink" title="Kotlin的类只有属性（property）没有独立的字段（field）"></a>Kotlin的类只有属性（property）没有独立的字段（field）</h2><p>如果上面的代码用kotlin翻译一下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以对比出，Kotlin里不需要额外的get、set方法，当然你也写不了，因为 Kotlin 已经默认实现了get、set，所以在Kotlin里，我们写不出 <strong>field</strong>。</p><h2 id="Kotlin-中的-backing-field-是什么"><a href="#Kotlin-中的-backing-field-是什么" class="headerlink" title="Kotlin 中的 backing field 是什么"></a>Kotlin 中的 backing field 是什么</h2><p>前面说 Kotlin 中不能写 field，但是我们很多时候必须要用到 field，比如你复写一个属性的set方法</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        age = value + <span class="number">1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果这样写其实是会发生递归，无法赋值成功<br><img src="http://wx3.sinaimg.cn/mw690/8127619aly1g6wt6adegmj20c005iglg.jpg" alt><br>这里AS也提醒你了，这里发生了递归<br>所以我们一般都这么写：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        field = value + <span class="number">1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里出现了一个 <strong>field</strong> 的东西可以访问和赋值，这个东西就是 Kotlin 的<strong>幕后字段（Backing Field）</strong><br>我们可以简单地理解为，Kotlin 没有明面上的 field，但是它存在于幕后</p><h2 id="没有-backing-field的成员是什么？"><a href="#没有-backing-field的成员是什么？" class="headerlink" title="没有 backing field的成员是什么？"></a>没有 backing field的成员是什么？</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _age =<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = _age</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            _age = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们声明一个 var 为私有时，比如上面的_age，我们叫它 <strong>幕后属性</strong> ,虽然它看起来不需要get、set方法，但是其实仍然是有的，只不过它的get、set方法都被声明为 private 了</p><p><strong>当然我们这里不是想讨论幕后属性</strong>，而是要讨论一下这个 age 是个什么玩意，是一个成员属性吗，其实通过字节码就可以知道，这里的Person类实际并不存在age这个成员，它只是帮你生成了对_age的两个public final的get和set方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// access flags 0x2</span><br><span class="line">private I _age</span><br><span class="line"></span><br><span class="line">// access flags 0x11</span><br><span class="line">public final getAge()I</span><br><span class="line"> L0</span><br><span class="line">  LINENUMBER 28 L0</span><br><span class="line">  ALOAD 0</span><br></pre></td></tr></table></figure><p>和你自己直接写一个</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getAge</span><span class="params">()</span></span> = _age</span><br></pre></td></tr></table></figure><p>是一模一样的  </p><p><strong>再举一个例子</strong>：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> View.topPadding: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">get</span>() = paddingTop</span><br><span class="line">    <span class="keyword">set</span>(value) = setPadding(paddingLeft, value, paddingRight, paddingBottom)</span><br></pre></td></tr></table></figure><p>这是从anko的拷出来一段代码，通过这个扩展成员，我们可以直接对某个 View 的 PaddingTop 进行修改和读取，虽然说是成员，但是我们把一段字节码拿出来看一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// access flags 0x19</span><br><span class="line">public final static getTopPadding(Landroid/view/View;)I</span><br><span class="line">  @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0****</span><br><span class="line">...</span><br><span class="line">// access flags 0x19</span><br><span class="line">public final static setTopPadding(Landroid/view/View;I)V</span><br><span class="line">  @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0</span><br></pre></td></tr></table></figure><p>很明显，这里就是直接生成了两个静态函数<code>getTopPadding</code>和<code>setTopPadding</code>，并不是真的为View这个类添加了一个成员，那这个东西到底什么呢？我们把上面的代码稍微改一下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> View.topPadding: <span class="built_in">Int</span> = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">get</span>() = paddingTop</span><br><span class="line">    <span class="keyword">set</span>(value) = setPadding(paddingLeft, value, paddingRight, paddingBottom)</span><br></pre></td></tr></table></figure><p>给这个成员加个默认值，可以看到，编辑器报错了<br><img src="http://wx2.sinaimg.cn/large/8127619aly1g6wt6dwnn4j210q03gq36.jpg" alt><br>并且告诉你这个属性没有幕后字段，所以不能初始化，好吧，官方给出了定义，<strong>这就是一个属性（property）</strong>。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Kotlin中一个 property 不管有没有 backing field 都称之为 property，而在 Java 中 field + get、set方法一起才能是一个 property。<br>如果我们从Java 的角度去看一个没有 backing field 的 property，可以理解为 Kotlin 对 以get、set开头这样的函数的语法糖，这种语法糖有什么用呢？个人觉得是为了DSL语法服务的，还是以上面那个topPadding为例，当你在用 DSL 语法设置一个view的时候，比如：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">view.apply &#123;</span><br><span class="line">    background = getDrawable(R.drawable.bg)</span><br><span class="line">    visibility = View.INVISIBLE</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面都是一个属性等于一个值，这个时候下面跟上 <code>topPadding = xxx</code>，语义十分清晰连贯，如果这里突然用一个 <code>setTopPadding(this,xxx)</code> ，不仅代码不美观，而且打断了阅读代码和编写代码的人的思维上的连贯性。</p><p>以上就是我对 Kotlin 的 Property 的理解</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章是一时兴起想写的，因为我发现我对Kotlin的属性理解一直有误&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://howshea.coding.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://howshea.coding.me/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>模仿Google News 的 TabLayout</title>
    <link href="https://howshea.coding.me/2019/04/22/%E6%A8%A1%E4%BB%BFGoogle-News%E7%9A%84TabLayout/"/>
    <id>https://howshea.coding.me/2019/04/22/模仿Google-News的TabLayout/</id>
    <published>2019-04-22T03:16:32.000Z</published>
    <updated>2019-09-12T08:09:58.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前景提要"><a href="#前景提要" class="headerlink" title="前景提要"></a>前景提要</h2><p>很久之前看到 Google News 的 <code>TabLayout</code> 的样式挺有意思的，如下图：</p><a id="more"></a><p><img src="http://wx2.sinaimg.cn/mw690/8127619aly1g6wsmsed2uj20u01o01kx.jpg" alt><br>具体效果大家可以自己下载 Google News 看一下，截图上大概看出来一共有两个要素：</p><ol><li>指示器和文字宽度相同</li><li>指示器的形状是半个圆角矩形</li></ol><p>于是，我模仿的结果：（截图来自我的一个小项目里<a href="https://github.com/howshea/GeekNews" target="_blank" rel="noopener">GeekNews</a>）<br><img src="http://wx3.sinaimg.cn/mw690/8127619aly1g6wsni87luj20u01o0tjy.jpg" alt></p><p>开始模仿之前，先问个问题，这个控件是 TabLayout 吗？答案：是的，我用 monitor 看过了。<br>所以可以得到结论：直接魔改源码是最简单最快的方法。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="魔改系统组件的第一步都是先把源码拷出来"><a href="#魔改系统组件的第一步都是先把源码拷出来" class="headerlink" title="魔改系统组件的第一步都是先把源码拷出来"></a>魔改系统组件的第一步都是先把源码拷出来</h3><p><img src="http://wx2.sinaimg.cn/large/8127619aly1g6wso4iv4uj20am06owel.jpg" alt><br>就这四个文件，拷出来改改里面一些类的引用路径，试一下能用就行了</p><h3 id="实现半个圆角矩形"><a href="#实现半个圆角矩形" class="headerlink" title="实现半个圆角矩形"></a>实现半个圆角矩形</h3><p>简单看一下 TabLayout 这个类的结构可以看出， TabLayout 内的指示器是由一个 私有内部类 <code>SlidingTabStrip</code> 来控制的，再看一下其中的 <code>draw</code> 方法实现，<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.draw(canvas);</span><br><span class="line">    <span class="comment">// Thick colored underline below the current selection</span></span><br><span class="line">    <span class="keyword">if</span> (mIndicatorLeft &gt;= <span class="number">0</span> &amp;&amp; mIndicatorRight &gt; mIndicatorLeft) &#123;</span><br><span class="line">        canvas.drawRect(mIndicatorLeft, getHeight() - mSelectedIndicatorHeight,</span><br><span class="line">mIndicatorRight, getHeight(), mSelectedIndicatorPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里画了一个矩形，从<code>mIndicatorLeft</code>、<code>mIndicatorRight</code>、<code>mSelectedIndicatorPaint</code>这几个变量的名字上就非常非常明显可以看出，这个矩形就是tab下面的那个矩形指示器条 (此处应有️配图)</p><p>这个地方我们可以先实现半个圆角矩形的效果，圆角很简单，把<code>drawRect</code> 换成 <code>drawRoundRect</code> 即可，半个矩形只要画一个超过控件最底部的rectF,让控件自己裁掉这个rectF的一半高度，圆角则取这个一半高度，就是<code>mSelectedIndicatorHeight</code>的值<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.draw(canvas);</span><br><span class="line">    <span class="comment">// Thick colored underline below the current selection</span></span><br><span class="line">    <span class="keyword">if</span> (mIndicatorLeft &gt;= <span class="number">0</span> &amp;&amp; mIndicatorRight &gt; mIndicatorLeft) &#123;</span><br><span class="line">        RectF rectF = <span class="keyword">new</span> RectF(mIndicatorLeft, getHeight() - mSelectedIndicatorHeight, mIndicatorRight, getHeight() + mSelectedIndicatorHeight);</span><br><span class="line">        mSelectedIndicatorPaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">        canvas.drawRoundRect(rectF, mSelectedIndicatorHeight, mSelectedIndicatorHeight, mSelectedIndicatorPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里我们仅利用已有的变量就能实现半个圆角矩形的效果。</p><h3 id="实现指示器宽度与文字等宽"><a href="#实现指示器宽度与文字等宽" class="headerlink" title="实现指示器宽度与文字等宽"></a>实现指示器宽度与文字等宽</h3><p>从上一步我们可以看到，指示器的宽度是由 <code>mIndicatorLeft</code> 和 <code>mIndicatorRight</code> 这两个变量决定的，那直接在draw方法里改？显然不行，想想，tab切换涉及两个tab的宽度计算，<code>mIndicatorLeft</code> 和 <code>mIndicatorRight</code>的计算不仅跟着位置改变还受到tab本身宽度的影响（其实我偷偷试过了，在这里改确实不行）。<br>首先，我们要找到 <code>mIndicatorLeft</code> 和 <code>mIndicatorRight</code> 被修改的地方，发现一个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIndicatorPosition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left != mIndicatorLeft || right != mIndicatorRight) &#123;</span><br><span class="line">        <span class="comment">// If the indicator's left/right has changed, invalidate</span></span><br><span class="line">        mIndicatorLeft = left;</span><br><span class="line">        mIndicatorRight = right;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们顺着这个方法被调用的地方终于找到 left 和 right 计算的地方：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateIndicatorPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> View selectedTitle = getChildAt(mSelectedPosition);</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">if</span> (selectedTitle != <span class="keyword">null</span> &amp;&amp; selectedTitle.getWidth() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        left = selectedTitle.getLeft();</span><br><span class="line">        right = selectedTitle.getRight();</span><br><span class="line">        <span class="keyword">if</span> (mSelectionOffset &gt; <span class="number">0f</span> &amp;&amp; mSelectedPosition &lt; getChildCount() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Draw the selection partway between the tabs</span></span><br><span class="line">            View nextTitle = getChildAt(mSelectedPosition + <span class="number">1</span>);</span><br><span class="line">            left = (<span class="keyword">int</span>) (mSelectionOffset * nextTitle.getLeft() + (<span class="number">1.0f</span> - mSelectionOffset) * left);</span><br><span class="line">            right = (<span class="keyword">int</span>) (mSelectionOffset * nextTitle.getRight() + (<span class="number">1.0f</span> - mSelectionOffset) * right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = right = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setIndicatorPosition(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>终于找到修改的地方了，首先我们要了解一下第一行 getChildAt 返回的 view 是个什么，这里就不贴代码了，直接说结论：阅读源码可知是个名为 TabView 的类，TabView 是个 LinearLayout，TabLayout 的文字是由其内部的mTextView来显示的。计算的思路就是下面的灵魂示意图：</p><p><img src="http://wx4.sinaimg.cn/mw690/8127619aly1g6wspttoixj215a0pugmk.jpg" alt><br>翻译成伪代码就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spacing = (view.width -view.mTextView.width)/2</span><br><span class="line">newLeft = view.left + spacing</span><br><span class="line">newRight = view.right - spacing</span><br></pre></td></tr></table></figure><p>所以修改之后的 <code>updateIndicatorPosition()</code> 方法如下，要注意需要修改两组left和right，一个是当前选中的Tab，一个是下一个Tab<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateIndicatorPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TabView selectedTitle = (TabView) getChildAt(mSelectedPosition);</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selectedTitle != <span class="keyword">null</span> &amp;&amp; selectedTitle.getWidth() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> spacing = (selectedTitle.getWidth() - selectedTitle.mTextView.getMeasuredWidth()) / <span class="number">2</span>;</span><br><span class="line">        left = selectedTitle.getLeft() + spacing;</span><br><span class="line">        right = selectedTitle.getRight() - spacing;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSelectionOffset &gt; <span class="number">0f</span> &amp;&amp; mSelectedPosition &lt; getChildCount() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Draw the selection partway between the tabs</span></span><br><span class="line">            TabView nextTitle = (TabView) getChildAt(mSelectedPosition + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> nextSpacing = (nextTitle.getWidth() - nextTitle.mTextView.getMeasuredWidth()) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> nextLeft = nextTitle.getLeft() + nextSpacing;</span><br><span class="line">            <span class="keyword">int</span> nextRight = nextTitle.getRight() - nextSpacing;</span><br><span class="line"></span><br><span class="line">            left = (<span class="keyword">int</span>) (mSelectionOffset * nextLeft +</span><br><span class="line">                            (<span class="number">1.0f</span> - mSelectionOffset) * left);</span><br><span class="line">            right = (<span class="keyword">int</span>) (mSelectionOffset * nextRight +</span><br><span class="line">                            (<span class="number">1.0f</span> - mSelectionOffset) * right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = right = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setIndicatorPosition(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就修改完了吗？不！要知道tab之间切换有两种方式，一个是 viewPager 划过去，还有一个是点击任意一个tab跳过去，所以还有一个地方要改，不需要找了，setIndicatorPosition 紧跟着的下一个方法就是，<code>void animateIndicatorToPosition(final int position, int duration)</code> ，我们只要改其中的这一段：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> View targetView = getChildAt(position);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> targetLeft = targetView.getLeft();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> targetRight = targetView.getRight();</span><br></pre></td></tr></table></figure></p><p>只需要改目标 view 的 left 和 right，因为这个方法里调用了一次 <code>updateIndicatorPosition()</code>，当前选中的 view 已经被计算过一次了。<br>修改后：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> TabView targetView = (TabView) getChildAt(position);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> targetSpacing = (targetView.getWidth() - targetView.mTextView.getMeasuredWidth()) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> targetLeft = targetView.getLeft() + targetSpacing;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> targetRight = targetView.getRight() - targetSpacing;</span><br></pre></td></tr></table></figure></p><p>至此，真的就全部完成了。<br>修改好的源码地址：<a href="https://github.com/howshea/GeekNews/blob/master/basemodule/src/main/java/com/howshea/basemodule/component/viewGroup/tabLayout/TabLayout.java" target="_blank" rel="noopener">TabLayout.java</a><br><img src="http://wx1.sinaimg.cn/mw690/8127619aly1g6wsqy2qcsj206o06o0sl.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前景提要&quot;&gt;&lt;a href=&quot;#前景提要&quot; class=&quot;headerlink&quot; title=&quot;前景提要&quot;&gt;&lt;/a&gt;前景提要&lt;/h2&gt;&lt;p&gt;很久之前看到 Google News 的 &lt;code&gt;TabLayout&lt;/code&gt; 的样式挺有意思的，如下图：&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://howshea.coding.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>数学在UI上的两个应用</title>
    <link href="https://howshea.coding.me/2018/09/03/%E6%95%B0%E5%AD%A6%E5%9C%A8UI%E4%B8%8A%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BA%94%E7%94%A8/"/>
    <id>https://howshea.coding.me/2018/09/03/数学在UI上的两个应用/</id>
    <published>2018-09-03T01:14:36.000Z</published>
    <updated>2019-06-10T11:33:38.104Z</updated>
    
    <content type="html"><![CDATA[<p>前几天听了一期设计师的播客节目，说到高斯模糊和投影的衰减，想起自己恰好研究过这两个问题，又回忆起池老师说的闭环原则，觉得有必要记录和分享出来。</p><p>偷偷推荐一下这个播客，这期播客链接在这里:  <a href="https://anyway.fm/science-in-ui-design/#title" target="_blank" rel="noopener">№ 71[学好数理化，做遍设计都不怕]</a></p><a id="more"></a><h1 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h1><p>高斯模糊是一种在移动端常见的设计，俗称毛玻璃效果，当然，在软件上我们难以模拟一个毛玻璃的光线效果，所以，高斯模糊是直接对图像进行处理。</p><p>先说一下模糊算法，简单来说，就是对每个像素的周围的像素取平均值之后重新设置这个像素的颜色</p><p><img src="http://wx4.sinaimg.cn/mw690/8127619agy1fuw4kfc9z7j20az096mwy.jpg" alt></p><p>我们常用的 blur 算法里要传的那个参数，即是周围取值的半径，如上图所示，半径为 1 时，只取周围一个像素的范围。</p><p>那取平均值和高斯有什么关系，实际上直接取平均值做出来的效果并不自然，因为图像是连续的，越靠近的像素关联度越高，所以这个平均值应该是一个加权平均值，而权重的计算符合高斯分布，说高斯分布可能多少人不熟，因为我们读高中的时候都叫它「正态分布」。</p><p><img src="http://wx1.sinaimg.cn/mw690/8127619agy1fuw4xsmfdnj20go0bowez.jpg" alt></p><p>以上高斯模糊的原理，就基本解释明朗了，下面说一下高斯模糊在实际开发里的 best practice。</p><p>我们已经知道了高斯模糊的计算方式，拿一个 1080 * 1920 px 的图片为例，像素点超过 200百万个，而且为了模糊效果平滑，我们通常会把半径设置的较大，一般是10，这个计算量是恐怖的，即使在高端机上也会有明显的卡顿，内存小的机器甚至会由于频繁GC造成处理失败，所以我通常的做法是先对图片做缩小处理，比如把 1080P 的图像缩小三倍，变成 360 * 640 px，这样计算量就小了至少10倍。</p><h1 id="投影衰减"><a href="#投影衰减" class="headerlink" title="投影衰减"></a>投影衰减</h1><p>投影效果在 UI 上应用广泛，在 google 的材料化设计中更是最重要的元素之一，但是无论设计还是开发都遇到过一个头疼的问题，就是投影效果的制作，因为自然的投影衰减并不是线性的。</p><p><img src="http://wx2.sinaimg.cn/mw690/8127619agy1fuw643votsj20zd0lfjst.jpg" alt></p><p>我们想要的渐变实际上应该符合图中红色的那个函数，但是软件只能做出符合蓝色的线性函数的渐变。</p><p>上面播客里主播有提到他们是用多层投影来模拟非线性的渐变（类似于求极限的思路）。在 Android 开发中，shape 也只能制作线性渐变，效果很不自然，而控件自带投影效果，5.0以下的系统实现不了，5.0以上的也不是所有组件都可以使用，而且不能调整颜色。</p><p>所幸的是，14年的时候一位 google 工程师就写出了相应的投影渐变算法: <a href="https://plus.google.com/+RomanNurik/posts/2QvHVFWrHZf" target="_blank" rel="noopener">plus.google.com</a>, 文中的算法链接已经失效了，因为他把算法用 Kotlin 重新实现了一遍。我把算法直接记录在这篇 blog 里，方便其他人阅读。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> cubicGradientScrimCache = LruCache&lt;<span class="built_in">Int</span>, Drawable&gt;(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="built_in">Float</span>.<span class="title">constrain</span><span class="params">(min: <span class="type">Float</span>, max: <span class="type">Float</span>)</span></span>: <span class="built_in">Float</span> = Math.max(min, Math.min(max, <span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an approximated cubic gradient using a multi-stop linear gradient. See</span></span><br><span class="line"><span class="comment"> * [this post](https://plus.google.com/+RomanNurik/posts/2QvHVFWrHZf) for more</span></span><br><span class="line"><span class="comment"> * details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">"RtlHardcoded"</span>)</span></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeCubicGradientScrimDrawable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    gravity: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    alpha: <span class="type">Int</span> = <span class="number">0xFF</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    red: <span class="type">Int</span> = <span class="number">0x0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    green: <span class="type">Int</span> = <span class="number">0x0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    blue: <span class="type">Int</span> = <span class="number">0x0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    requestedStops: <span class="type">Int</span> = <span class="number">8</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Drawable &#123;</span><br><span class="line">    <span class="keyword">var</span> numStops = requestedStops</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate a cache key by hashing together the inputs, based on the method described in the Effective Java book</span></span><br><span class="line">    <span class="keyword">var</span> cacheKeyHash = Color.argb(alpha, red, green, blue)</span><br><span class="line">    cacheKeyHash = <span class="number">31</span> * cacheKeyHash + numStops</span><br><span class="line">    cacheKeyHash = <span class="number">31</span> * cacheKeyHash + gravity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cachedGradient = cubicGradientScrimCache.<span class="keyword">get</span>(cacheKeyHash)</span><br><span class="line">    <span class="keyword">if</span> (cachedGradient != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedGradient</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numStops = Math.max(numStops, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> paintDrawable = PaintDrawable().apply &#123;</span><br><span class="line">        shape = RectShape()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stopColors = IntArray(numStops)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until numStops) &#123;</span><br><span class="line">        <span class="keyword">val</span> x = i * <span class="number">1</span>f / (numStops - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> opacity = Math.pow(x.toDouble(), <span class="number">3.0</span>).toFloat().constrain(<span class="number">0</span>f, <span class="number">1</span>f)</span><br><span class="line">        stopColors[i] = Color.argb((alpha * opacity).toInt(), red, green, blue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> x0: <span class="built_in">Float</span></span><br><span class="line">    <span class="keyword">val</span> x1: <span class="built_in">Float</span></span><br><span class="line">    <span class="keyword">val</span> y0: <span class="built_in">Float</span></span><br><span class="line">    <span class="keyword">val</span> y1: <span class="built_in">Float</span></span><br><span class="line">    <span class="keyword">when</span> (gravity and Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">        Gravity.LEFT -&gt; &#123;</span><br><span class="line">            x0 = <span class="number">1</span>f</span><br><span class="line">            x1 = <span class="number">0</span>f</span><br><span class="line">        &#125;</span><br><span class="line">        Gravity.RIGHT -&gt; &#123;</span><br><span class="line">            x0 = <span class="number">0</span>f</span><br><span class="line">            x1 = <span class="number">1</span>f</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            x0 = <span class="number">0</span>f</span><br><span class="line">            x1 = <span class="number">0</span>f</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">when</span> (gravity and Gravity.VERTICAL_GRAVITY_MASK) &#123;</span><br><span class="line">        Gravity.TOP -&gt; &#123;</span><br><span class="line">            y0 = <span class="number">1</span>f</span><br><span class="line">            y1 = <span class="number">0</span>f</span><br><span class="line">        &#125;</span><br><span class="line">        Gravity.BOTTOM -&gt; &#123;</span><br><span class="line">            y0 = <span class="number">0</span>f</span><br><span class="line">            y1 = <span class="number">1</span>f</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            y0 = <span class="number">0</span>f</span><br><span class="line">            y1 = <span class="number">0</span>f</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    paintDrawable.shaderFactory = <span class="keyword">object</span> : ShapeDrawable.ShaderFactory() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resize</span><span class="params">(width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span>: Shader &#123;</span><br><span class="line">            <span class="keyword">return</span> LinearGradient(</span><br><span class="line">                width * x0,</span><br><span class="line">                height * y0,</span><br><span class="line">                width * x1,</span><br><span class="line">                height * y1,</span><br><span class="line">                stopColors, <span class="literal">null</span>,</span><br><span class="line">                Shader.TileMode.CLAMP)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cubicGradientScrimCache.put(cacheKeyHash, paintDrawable)</span><br><span class="line">    <span class="keyword">return</span> paintDrawable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今年的第二篇 blog，依旧没什么技术含量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天听了一期设计师的播客节目，说到高斯模糊和投影的衰减，想起自己恰好研究过这两个问题，又回忆起池老师说的闭环原则，觉得有必要记录和分享出来。&lt;/p&gt;
&lt;p&gt;偷偷推荐一下这个播客，这期播客链接在这里:  &lt;a href=&quot;https://anyway.fm/science-in-ui-design/#title&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;№ 71[学好数理化，做遍设计都不怕]&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://howshea.coding.me/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="UI" scheme="https://howshea.coding.me/tags/UI/"/>
    
      <category term="数学" scheme="https://howshea.coding.me/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>安装黑苹果踩坑记录</title>
    <link href="https://howshea.coding.me/2018/08/02/%E5%AE%89%E8%A3%85%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://howshea.coding.me/2018/08/02/安装黑苹果踩坑记录/</id>
    <published>2018-08-01T16:42:31.000Z</published>
    <updated>2019-06-10T11:33:38.103Z</updated>
    
    <content type="html"><![CDATA[<p>最近给公司的 PC 装上了 macOS，出发点是13寸 mbp 确实性能不好，PC 闲置着又很浪费，而且这个13寸的mbp是我厚颜无耻跟领导蹭来的，一直不还也不好。来来回回折腾了几次，终于是几乎完美了，顺便还帮同事朱小哥也装了 macOS，i7-7700 + GTX1060 的 macOS High Sierra，配上开启了 HiDPI 的 Dell 2k 显示器，用来工作可以说是美滋滋了。</p><p>踩坑的过程痛苦又自得其乐，遂记录于此。</p><a id="more"></a><h1 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h1><p>首页，基本的安装教程来自以下这个链接:</p><p><a href="https://www.tonymacx86.com/threads/unibeast-install-macos-high-sierra-on-any-supported-intel-based-pc.235474/" target="_blank" rel="noopener">UniBeast: Install macOS High Sierra on Any Supported Intel-based PC</a></p><p>所以从标题上也可以看到了：</p><ul><li>基于 Intel 体系的，所以 AMD 的芯片组和 CPU 就别想了</li><li>PC，所以笔记本就别想了</li></ul><p>另外，基于这个网站的教程，还有一个先决条件：</p><p>你得先有一台真 mac 机器，macbook pro 或者 iMac 之类的，因为U盘的制作需要在白苹果内完成（教程中有详细说明）</p><h1 id="Problems-and-solutions"><a href="#Problems-and-solutions" class="headerlink" title="Problems and solutions"></a>Problems and solutions</h1><h2 id="制作U盘引导报错：copy-of-apfs-efi-failed"><a href="#制作U盘引导报错：copy-of-apfs-efi-failed" class="headerlink" title="制作U盘引导报错：copy of apfs.efi failed"></a>制作U盘引导报错：copy of apfs.efi failed</h2><p>这个问题是U盘没有 EFI 分区，可以在 Terminal 中执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo diskutil partitionDisk disk2 GPT JHFS+ USB R</span><br></pre></td></tr></table></figure><p>关于这个命令，diskutil 是 macOS 内置的命令行磁盘工具，建议学习一下啊，后面还有用到的地方，disk2 是你的U盘的节点，所以最好先用 <code>diskutil list</code> 这个命令查看一下当前U盘的节点，万一搞错了问题就很大了。</p><p><img src="http://wx3.sinaimg.cn/large/8127619agy1ftuqzt6yrfj205i05cdfv.jpg" alt></p><h2 id="U盘启动后进不了-Recovery，屏幕显示一个禁止的符号"><a href="#U盘启动后进不了-Recovery，屏幕显示一个禁止的符号" class="headerlink" title="U盘启动后进不了 Recovery，屏幕显示一个禁止的符号"></a>U盘启动后进不了 Recovery，屏幕显示一个禁止的符号</h2><p>这其实一个多重问题，U盘的问题和 usb 接口的问题，我先是用了一个活动送的U盘，不管换哪个接口都不行，后来换了个闪迪的U盘，终于进安装界面了，中间还出现了一个问题，在给同事安装系统的过程中出现了一个镜像过期的提示，后来换了另外一个 usb 接口就OK了。</p><p>理论上来说最好选用2.0的U盘和2.0的 usb 接口，容易一次过。</p><h2 id="对系统盘执行擦除时失败"><a href="#对系统盘执行擦除时失败" class="headerlink" title="对系统盘执行擦除时失败"></a>对系统盘执行擦除时失败</h2><p>因为很多 PC 都会对硬盘分区，所以到这一步骤有可能会出现这个问题，macOS 的图形化磁盘工具不是很好用，这个时候就要用到 diskutil 命令行工具啦</p><ol><li>执行 <code>diskutil list</code> 找到你要格式化的硬盘的节点，比如我的那块 ssd 是 disk0。</li><li>执行 <code>diskutil eraseDisk JHFS+ macOS disk0</code>，JHFS+ 是 Mac OS Extended (Journaled) 格式，也就是教程中需要的格式，macOS是对磁盘重命名的名字，这个名字写什么全凭个人喜好了。</li></ol><h2 id="3-5mm-耳机接口用不了"><a href="#3-5mm-耳机接口用不了" class="headerlink" title="3.5mm 耳机接口用不了"></a>3.5mm 耳机接口用不了</h2><p>虽然我用的是蓝牙耳机用不到这个接口，但是追求完美，这个问题还是要解决，在 MultiBeast 中配置 Audio 驱动时，选择 VoodooHDA，这是一个万能音频驱动。</p><h2 id="显示器设置中没有-HiDPI选项"><a href="#显示器设置中没有-HiDPI选项" class="headerlink" title="显示器设置中没有 HiDPI选项"></a>显示器设置中没有 HiDPI选项</h2><p>威锋网上有一篇靠谱的教程：<a href="https://bbs.feng.com/forum.php?mod=viewthread&amp;tid=11104214" target="_blank" rel="noopener">开启HiDPI（黑苹果通用。10.12.3通过）</a></p><p>要注意一点是那个配置文件是没有后缀的，一开始我怎么弄都不对是因为文件后缀被隐藏了。</p><p>亲测 25寸的 2k 显示器 开启 1920*1080 的 HiDPI 效果最好。</p><h2 id="显存数值不对"><a href="#显存数值不对" class="headerlink" title="显存数值不对"></a>显存数值不对</h2><p>1060 的 3GB 的显存显示 256MB，编辑 EFI 分区里的 config.plist 文件（至于怎么挂载 EFI 分区怎么修改这个文件，字数够另写一篇blog了，懒得细说了），把其中的 Inject Nvidia 改为 false。</p><h2 id="无线网卡不识别"><a href="#无线网卡不识别" class="headerlink" title="无线网卡不识别"></a>无线网卡不识别</h2><p>这个真没办法了，板载的无线网卡没有驱动，真的有这个需求只能去买一个 usb 外置网卡或者 PCIe的无线网卡，或许有用，反正办公室的 PC 都是插网线的，所以这个问题真的不大。</p><h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p><img src="http://wx2.sinaimg.cn/large/8127619agy1ftusidjuy1j21kw0w0dm7.jpg" alt></p><p>就一句话，工作开心最重要</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近给公司的 PC 装上了 macOS，出发点是13寸 mbp 确实性能不好，PC 闲置着又很浪费，而且这个13寸的mbp是我厚颜无耻跟领导蹭来的，一直不还也不好。来来回回折腾了几次，终于是几乎完美了，顺便还帮同事朱小哥也装了 macOS，i7-7700 + GTX1060 的 macOS High Sierra，配上开启了 HiDPI 的 Dell 2k 显示器，用来工作可以说是美滋滋了。&lt;/p&gt;
&lt;p&gt;踩坑的过程痛苦又自得其乐，遂记录于此。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="macOS" scheme="https://howshea.coding.me/tags/macOS/"/>
    
      <category term="黑苹果" scheme="https://howshea.coding.me/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习笔记（二）</title>
    <link href="https://howshea.coding.me/2017/09/11/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>https://howshea.coding.me/2017/09/11/Kotlin学习笔记二/</id>
    <published>2017-09-11T09:31:53.000Z</published>
    <updated>2019-06-10T11:33:38.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这一篇是高阶一点的知识</p></blockquote><a id="more"></a><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>传入或返回函数的函数</li><li><p>包级函数引用:</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    args.forEach(::println)</span><br><span class="line">    args.forEach(::printTwoLn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printTwoLn</span><span class="params">(message: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"<span class="variable">$message</span>\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类名加函数名应用，包含一个隐藏的参数——调用者本身</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    args.filter(String::isNotEmpty)</span><br><span class="line">    println(args.filter(String::isOops))<span class="comment">// print [!,!]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">isOops</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> equals(<span class="string">"!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>带有 Receiver 的引用（从 Kotlin1.1 之后才支持的语法）</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pdfPrinter = PdfPrinter()</span><br><span class="line">    args.forEach(pdfPrinter::println)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PdfPrinter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">println</span><span class="params">(any: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        kotlin.io.println(any)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常见高阶函数"><a href="#常见高阶函数" class="headerlink" title="常见高阶函数"></a>常见高阶函数</h2><ul><li><p><code>map</code> 映射，返回类型任意</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">23</span>, <span class="number">53</span>)</span><br><span class="line"><span class="keyword">val</span> newList = list.map &#123; it * <span class="number">2</span> + <span class="number">3</span> &#125;</span><br><span class="line">println(newList) <span class="comment">// print [5, 9, 11, 15, 49, 109]</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> newList2 = list.map(<span class="built_in">Int</span>::toDouble)</span><br><span class="line">   println(newList2) <span class="comment">//print [1.0, 3.0, 4.0, 6.0, 23.0, 53.0]</span></span><br></pre></td></tr></table></figure></li><li><p><code>flatMap</code> 铺平集合的集合,返回任意类型</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> listFlat = listOf&lt;IntRange&gt;(</span><br><span class="line">        <span class="number">1.</span><span class="number">.3</span>,</span><br><span class="line">        <span class="number">8.</span><span class="number">.10</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> flatMapList = listFlat.flatMap &#123;</span><br><span class="line">    it.map &#123;</span><br><span class="line">        <span class="string">"No. <span class="variable">$it</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print [No. 1, No. 2, No. 3, No. 8, No. 9, No. 10]</span></span><br><span class="line">println(flatMapList)</span><br></pre></td></tr></table></figure></li><li><p><code>reduce</code> 表达式包含两个参数，上一次运算的结果和当前的迭代的值，acc 必须是 i 的父类</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求和</span></span><br><span class="line"><span class="keyword">val</span> sum = list.reduce &#123; acc, i -&gt; acc + i &#125;</span><br><span class="line"><span class="comment">//阶乘</span></span><br><span class="line"><span class="keyword">val</span> factorial = (<span class="number">1.</span><span class="number">.6</span>).reduce &#123; acc, i -&gt; acc * i &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>fold</code> ，reduce 的增强版，增加一个初始值的参数，Lambda 表达式参数的类型没有限制，<code>foldRight</code> 是 <code>fold</code> 倒序操作，还有 <code>foldIndexed</code>, <code>foldRightIndexed</code> 提供更多功能</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//return "List,1,3,4,6,23,53"</span></span><br><span class="line">list.fold(<span class="string">"List"</span>) &#123; acc, i -&gt; <span class="string">"<span class="variable">$acc</span>,<span class="variable">$i</span>"</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>filter</code> , 用于过滤，还有 <code>filterIndexed</code> 等增强型函数</p></li><li><p><code>takeWhile</code> 和 filter 类似，但是遇到第一个不符合条件的就停止迭代</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遇到第一个偶数就停止迭代</span></span><br><span class="line">list.takeWhile &#123; it % <span class="number">2</span> == <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>let</code></p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">work</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findPerson</span><span class="params">()</span></span>: Person? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    findPerson()?.let &#123;</span><br><span class="line">        it.work()</span><br><span class="line">        println(it.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>apply</code>，和 <code>let</code> 略有不同</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    findPerson()?.apply &#123; </span><br><span class="line">        work()</span><br><span class="line">        println(age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>with</code>， 和 <code>apply</code> 类似，但是不能是可空类型</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> br = BufferedReader(FileReader(<span class="string">"hello.txt"</span>))</span><br><span class="line">    with(br)&#123;</span><br><span class="line">        <span class="keyword">var</span> line:String?</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            line =readLine()?:<span class="keyword">break</span></span><br><span class="line">            println(line)</span><br><span class="line">        &#125;</span><br><span class="line">        close()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>use</code> , 避免写 close,it不能省略</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">BufferedReader(FileReader(<span class="string">"hello.txt"</span>)).use &#123;</span><br><span class="line">    <span class="keyword">var</span> line: String?</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        line = it.readLine() ?: <span class="keyword">break</span></span><br><span class="line">        println(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h2><ul><li>对于尾递归的函数，前面加上 <code>tailrec</code> 关键字  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>, <span class="keyword">var</span> next: ListNode?=<span class="literal">null</span>)</span><br><span class="line">tailrec <span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head: <span class="type">ListNode</span>?, value: <span class="type">Int</span>)</span></span>: ListNode? &#123;</span><br><span class="line">    head ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>函数运行的环境，持有函数运行状态，函数内部可以定义函数，也可以定义类</li><li>例子，斐波那契数列  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fibonacci</span><span class="params">()</span></span>: Iterable&lt;<span class="built_in">Long</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> first = <span class="number">0</span>L</span><br><span class="line">    <span class="keyword">var</span> second = <span class="number">1</span>L</span><br><span class="line">    <span class="keyword">return</span> Iterable &#123;</span><br><span class="line">        <span class="keyword">object</span> : LongIterator() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">nextLong</span><span class="params">()</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> result = second</span><br><span class="line">                second += first</span><br><span class="line">                first = second - first</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span> = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    fibonacci()</span><br><span class="line">            .takeWhile &#123; it &lt;= <span class="number">100</span> &#125;</span><br><span class="line">            .forEach(::println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h2><ul><li>f(g(x))  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> add5 = &#123; i: <span class="built_in">Int</span> -&gt; i + <span class="number">5</span> &#125;</span><br><span class="line"><span class="keyword">val</span> multiplyBy2 = &#123; i: <span class="built_in">Int</span> -&gt; i * <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;P1, P2, R&gt;</span> Function1<span class="type">&lt;P1, P2&gt;</span>.<span class="title">andThen</span><span class="params">(function: <span class="type">Function1</span>&lt;<span class="type">P2</span>, R&gt;)</span></span>: Function1&lt;P1, R&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(p1: <span class="type">P1</span>)</span></span>: R &#123;</span><br><span class="line">        <span class="keyword">return</span> function(<span class="keyword">this</span>(p1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> add5AndMultiPlyBy2 = add5 andThen multiplyBy2</span><br><span class="line">    println(add5AndMultiPlyBy2(<span class="number">11</span>)) <span class="comment">//print 32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="科里化（Currying）"><a href="#科里化（Currying）" class="headerlink" title="科里化（Currying）"></a>科里化（Currying）</h2><ul><li>多元函数变换成一元函数调用链  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原始函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(tag: <span class="type">String</span>, target: <span class="type">OutputStream</span>, message: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">    target.write(<span class="string">"[<span class="variable">$tag</span>] <span class="variable">$message</span>\n"</span>.toByteArray())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(tag: <span class="type">String</span>)</span></span></span><br><span class="line">        = <span class="function"><span class="title">fun</span><span class="params">(target: <span class="type">OutputStream</span>)</span></span></span><br><span class="line">        = <span class="function"><span class="title">fun</span><span class="params">(message: <span class="type">Any</span>?)</span></span></span><br><span class="line">                = target.write(<span class="string">"[<span class="variable">$tag</span>] <span class="variable">$message</span>\n"</span>.toByteArray())</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">log(<span class="string">"benny"</span>)(System.<span class="keyword">out</span>)(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="comment">//方式二（扩展函数）</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;P1, P2, P3, R&gt;</span> Function3<span class="type">&lt;P1, P2, P3, R&gt;</span>.<span class="title">curried</span><span class="params">()</span></span></span><br><span class="line">        = <span class="function"><span class="title">fun</span><span class="params">(p1: <span class="type">P1</span>)</span></span> = <span class="function"><span class="title">fun</span><span class="params">(p2: <span class="type">P2</span>)</span></span> = <span class="function"><span class="title">fun</span><span class="params">(p3: <span class="type">P3</span>)</span></span> = <span class="keyword">this</span>(p1, p2, p3)</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">::log.curried()(<span class="string">"benny"</span>)(System.<span class="keyword">out</span>)(<span class="string">"Hello"</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><ul><li>传入部分参数得到的新函数</li><li><p>示例1,需要固定的参数在前面</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> consoleLogWithTag = (::log.curried())(<span class="string">"benny"</span>)(System.<span class="keyword">out</span>)</span><br><span class="line">consoleLogWithTag(<span class="string">"Hello Again."</span>)</span><br></pre></td></tr></table></figure></li><li><p>示例2，需要固定的参数在后面</p> <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeString</span><span class="params">(byteArray: <span class="type">ByteArray</span>, charset: <span class="type">Charset</span>)</span></span> = String(byteArray, charset)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;P1, P2, R&gt;</span> Function2<span class="type">&lt;P1, P2, R&gt;</span>.<span class="title">partial2</span><span class="params">(p2: <span class="type">P2</span>)</span></span> = <span class="function"><span class="title">fun</span><span class="params">(p1: <span class="type">P1</span>)</span></span> = <span class="keyword">this</span>(p1, p2)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> makeStringFromGbkBytes = ::makeString.partial2(charset(<span class="string">"GBK"</span>))</span><br><span class="line">    makeStringFromGbkBytes(<span class="string">"World"</span>.toByteArray())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="领域特定语言-DSL"><a href="#领域特定语言-DSL" class="headerlink" title="领域特定语言 DSL"></a>领域特定语言 DSL</h1><h2 id="HTML-DSL"><a href="#HTML-DSL" class="headerlink" title="HTML DSL"></a>HTML DSL</h2><ul><li>示例：  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">    <span class="string">"id"</span>(<span class="string">"htmlId"</span>)</span><br><span class="line">    head &#123;</span><br><span class="line">        <span class="string">"id"</span>(<span class="string">"headId"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">        id = <span class="string">"bodyId"</span></span><br><span class="line">        `<span class="class"><span class="keyword">class</span>` = "<span class="title">bodyCl</span></span></span><br><span class="line">        <span class="string">"a"</span>&#123;</span><br><span class="line">            <span class="string">"href"</span>(<span class="string">"https</span></span><br><span class="line"><span class="string">            +"</span>kotlin博大精深<span class="string">"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;.render().let(::println)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Gradle-Kotlin-脚本"><a href="#Gradle-Kotlin-脚本" class="headerlink" title="Gradle Kotlin 脚本"></a>Gradle Kotlin 脚本</h2><ul><li>把 build.gradle 文件改成 build.gradle.kts</li><li>修改为 Kotlin 的 DSL  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">group = <span class="string">"com.howshea.KotlinLearning2"</span></span><br><span class="line">version = <span class="string">"1.0-SNAPSHOT"</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    extra[<span class="string">"kotlin_version"</span>] = <span class="string">"1.1.4-2"</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="subst">$&#123;extra["kotlin_version"]&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply &#123;</span><br><span class="line">    plugin(<span class="string">"java"</span>)</span><br><span class="line">    plugin(<span class="string">"kotlin"</span>)</span><br><span class="line">&#125;</span><br><span class="line">configure&lt;JavaPluginConvention&gt; &#123;</span><br><span class="line">    setSourceCompatibility(<span class="number">1.8</span>)</span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="string">"compile"</span>(<span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jre8:<span class="subst">$&#123;extra["kotlin_version"]&#125;</span>"</span>)</span><br><span class="line">    <span class="string">"TestCompile"</span>(<span class="string">"junit:junit:4.12"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="协程-Coroutine"><a href="#协程-Coroutine" class="headerlink" title="协程 Coroutine"></a>协程 Coroutine</h1><h2 id="协程的概念"><a href="#协程的概念" class="headerlink" title="协程的概念"></a>协程的概念</h2><ul><li>协作程序，解决异步问题</li><li>应用层完成调度</li><li>支持协程的语言：Lua, C# 等</li></ul><h2 id="协程要解决的问题"><a href="#协程要解决的问题" class="headerlink" title="协程要解决的问题"></a>协程要解决的问题</h2><ul><li>异步代码像同步代码一样直观</li><li>简化异步代码处理</li><li>轻量级的并发方案</li></ul><h2 id="Kotlin-的协程支持"><a href="#Kotlin-的协程支持" class="headerlink" title="Kotlin 的协程支持"></a>Kotlin 的协程支持</h2><ul><li>编译器对 suspend 函数的编译支持</li><li>标准库 API 的支持</li><li>kotlinx.coroutine 应用级支持</li></ul><h2 id="协程的基本-API"><a href="#协程的基本-API" class="headerlink" title="协程的基本 API"></a>协程的基本 API</h2><ul><li><code>createCoroutine</code> 创建协程</li><li><code>startCoroutine</code> 启动协程</li><li><code>suspendCoroutine</code> 挂起协程</li><li><code>Continuation</code> 接口，运行控制类，负责结果和异常的返回</li><li><code>CoroutineContext</code> 接口，运行上下文，资源持有，运行调度</li><li><code>ContinuationInterceptor</code> 接口，协程控制拦截器，可用来处理协程调度</li></ul><h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol><li>协程编译成状态机</li><li><code>suspend</code> 函数即状态转移</li></ol><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><ol><li>正常结果通过 resume 返回</li><li>异常通过 resumeWithException 抛出</li></ol><h2 id="buildSequence-序列生成器"><a href="#buildSequence-序列生成器" class="headerlink" title="buildSequence 序列生成器"></a>buildSequence 序列生成器</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> fibonacci)&#123;</span><br><span class="line">        println(i)</span><br><span class="line">        <span class="keyword">if</span> (i&gt; <span class="number">100</span>) <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> fibonacci = buildSequence&#123;</span><br><span class="line">    yield(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> cur = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> next = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        yield(next)</span><br><span class="line">        <span class="keyword">val</span> tmp = cur + next</span><br><span class="line">        cur = next</span><br><span class="line">        next = tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kotlinx-coroutine-框架"><a href="#Kotlinx-coroutine-框架" class="headerlink" title="Kotlinx.coroutine 框架"></a>Kotlinx.coroutine 框架</h2><ul><li>主要模块<ul><li><code>kotlinx-coroutines-core</code> 核心库</li><li><code>kotlinx-coroutines-jdk8</code> Java8 支持库</li><li><code>kotlinx-coroutines-nio</code> 异步IO库</li><li><code>kotlinx-coroutines-reactive</code> Reactive Streams 支持</li><li><code>kotlinx-coroutines-reactor</code> Reactor 支持</li><li><code>kotlinx-coroutines-rx1</code> RxJava 1.x 支持</li><li><code>kotlinx-coroutines-rx2</code> Rxjava2.x 支持</li><li><code>kotlinx-coroutines-android</code> Android UI 支持</li><li><code>kotlinx-coroutines-javafx</code> JavaFx UI 支持</li><li><code>kotlinx-corountines-swing</code> Swing UI 支持</li></ul></li></ul><h1 id="Kotlin-与-Java-混合开发"><a href="#Kotlin-与-Java-混合开发" class="headerlink" title="Kotlin 与 Java 混合开发"></a>Kotlin 与 Java 混合开发</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="属性读写"><a href="#属性读写" class="headerlink" title="属性读写"></a>属性读写</h3><ul><li>Kotlin 自动识别 Java Getter/Setter</li><li>Java 操作 Kotlin 属性通过 Getter/Setter</li></ul><h3 id="空安全类型"><a href="#空安全类型" class="headerlink" title="空安全类型"></a>空安全类型</h3><ul><li>Java 不支持空安全，需要开发者自己注意</li><li>在 Java 代码中使用 <code>@Nullable</code> 和 <code>@NotNull</code> </li></ul><h3 id="几类函数的调用"><a href="#几类函数的调用" class="headerlink" title="几类函数的调用"></a>几类函数的调用</h3><ul><li>包级函数：静态方法</li><li>扩展方法：带 Receiver 的静态方法</li><li>运算符重载：带 Receiver 的对应名称的静态方法</li></ul><h3 id="常用注解的使用"><a href="#常用注解的使用" class="headerlink" title="常用注解的使用"></a>常用注解的使用</h3><ul><li><code>@JvmField</code>：将属性编译为 Java 变量</li><li><code>@JvmStatic</code>：将对象的方法编译成 Java 静态方法</li><li><code>@JvmOverloads</code>：默认参数生成重载方法</li><li><code>@file</code> : JvmName : 指定 Kotlin 文件编译后的类名</li></ul><h3 id="NoArg-与-AllOpen"><a href="#NoArg-与-AllOpen" class="headerlink" title="NoArg 与 AllOpen"></a>NoArg 与 AllOpen</h3><ul><li>NoArg 为被标注的类生成无参构造</li><li>AllOpen 为被标注的类去掉 final，允许被继承</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li>通配符 Kotlin 的 * 对应于 Java 的 ？</li><li>协变和逆变 out/in 对应 Java 的 &lt;? extends E&gt; 和 &lt;? super E&gt;</li><li>kotlin 没有 Raw 类型， Java 的 List 对应 Kotlin 的 List&lt;*&gt;</li></ul><h2 id="SAM-转换"><a href="#SAM-转换" class="headerlink" title="SAM 转换"></a>SAM 转换</h2><ul><li>Single Abstract Method</li><li>SAM 转换的条件<ul><li>Java 的接口，单一接口方法</li></ul></li><li>注意转换后实例的变化</li></ul><h2 id="Kotlin-的正则"><a href="#Kotlin-的正则" class="headerlink" title="Kotlin 的正则"></a>Kotlin 的正则</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> source = <span class="string">"Hello , This my phone number: 010-12345678."</span></span><br><span class="line"><span class="comment">//使用raw string，不需要转义字符</span></span><br><span class="line"><span class="keyword">val</span> pattern = <span class="string">""".*(\d&#123;3&#125;-\d&#123;8&#125;).*"""</span></span><br><span class="line">Regex(pattern).findAll(source).toList().flatMap(MatchResult::groupValues).forEach(::println)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这一篇是高阶一点的知识&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="https://howshea.coding.me/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="https://howshea.coding.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://howshea.coding.me/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习笔记（一）</title>
    <link href="https://howshea.coding.me/2017/08/19/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://howshea.coding.me/2017/08/19/Kotlin学习笔记/</id>
    <published>2017-08-19T12:36:01.000Z</published>
    <updated>2019-06-10T11:33:38.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-简介"><a href="#Kotlin-简介" class="headerlink" title="Kotlin 简介"></a>Kotlin 简介</h1><h2 id="Kotlin-是什么"><a href="#Kotlin-是什么" class="headerlink" title="Kotlin 是什么"></a>Kotlin 是什么</h2><ul><li>Android 官方开发语言，100% 兼容 Java</li><li>Kotlin-Js 前端开发</li><li>Kotlin-Jvm 服务端开发</li><li>Kotlin-Native 本地执行程序<a id="more"></a></li></ul><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> aBoolean:<span class="built_in">Boolean</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h2><ol><li><p>Int ( 32 位)</p> <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//十六进制</span></span><br><span class="line"><span class="keyword">val</span> hexInt: <span class="built_in">Int</span> = <span class="number">0xff</span></span><br><span class="line"><span class="comment">//二进制</span></span><br><span class="line"><span class="keyword">val</span> binInt: <span class="built_in">Int</span> = <span class="number">0</span>b000011</span><br><span class="line"><span class="comment">//kotlin 不支持直接表示 8 进制</span></span><br></pre></td></tr></table></figure></li><li><p>Long ( 64 位)</p> <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未超过 Int 范围的数值需要加“L"</span></span><br><span class="line"><span class="keyword">val</span> aLong:<span class="built_in">Long</span> = <span class="number">123</span>L</span><br></pre></td></tr></table></figure></li><li><p>Float</p> <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//必须加 f</span></span><br><span class="line"><span class="keyword">val</span> aFloat:<span class="built_in">Float</span>=<span class="number">1.0</span>F</span><br><span class="line"><span class="comment">//1000.0</span></span><br><span class="line"><span class="keyword">val</span> anotherFloat:<span class="built_in">Float</span>=<span class="number">1E3</span>F</span><br><span class="line"><span class="comment">//负无穷</span></span><br><span class="line"><span class="keyword">val</span> negativeInfinity: <span class="built_in">Float</span> = <span class="built_in">Float</span>.NEGATIVE_INFINITY</span><br><span class="line"><span class="comment">//正无穷</span></span><br><span class="line"><span class="keyword">val</span> positivieInfinity: <span class="built_in">Float</span> = <span class="built_in">Float</span>.POSITIVE_INFINITY</span><br><span class="line"><span class="comment">//not a number</span></span><br><span class="line"><span class="keyword">val</span> nan:<span class="built_in">Float</span> = <span class="built_in">Float</span>.NaN</span><br></pre></td></tr></table></figure></li><li><p>Double</p> <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> aDouble:<span class="built_in">Double</span> = <span class="number">2.0</span></span><br></pre></td></tr></table></figure></li><li><p>Short ( 16位 max : ( 2 ^ 15 ) - 1 == 32767 )</p></li><li>Byte ( 8位 max : 127)</li></ol><blockquote><p>Kotlin 里不区分装箱和非装箱类型</p></blockquote><h2 id="Char类型"><a href="#Char类型" class="headerlink" title="Char类型"></a>Char类型</h2><ul><li>占两个字节，表示一个 16 位的 Unicode 字符</li><li>用单引号</li><li>转义字符<blockquote><p>\t 制表符<br>\b 光标后退一个字符<br>\b 换行符<br>\r 光标回到行首<br>\‘ 单引号<br>\“ 双引号<br>\\ 反斜杠<br>\$ Kotlin支持$开头的字符串模板</p></blockquote></li></ul><h2 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h2><blockquote><p>Kotlin 不允许隐式转换</p></blockquote><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> anInt: <span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> aLong: <span class="built_in">Long</span> = anInt.toLong()</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> string: String = <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">val</span> fromChars: String = String(charArrayOf(<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>))</span><br></pre></td></tr></table></figure><ul><li>Kotlin中字符串比较<ul><li>使用 <code>==</code> 等价于 Java 中的 <code>equals()</code>，表示比较内容</li><li>使用 <code>===</code> 相当于 Java 的 <code>==</code> ，表示比较对象是否相同</li></ul></li><li><p>Kotlin支持字符串模板</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> arg1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> arg2 = <span class="number">2</span></span><br><span class="line">println(<span class="string">"<span class="variable">$arg1</span> + <span class="variable">$arg2</span> = <span class="subst">$&#123;arg1 + arg2&#125;</span>"</span>)</span><br></pre></td></tr></table></figure></li><li><p>Kotlin 支持原生字符串，使用三个双引号隔开，可以包含没有转义的、换行符和任意其他字符,在原生字符串中不支持转义，但是仍然支持字符串模板</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rawString = <span class="string">"""</span></span><br><span class="line"><span class="string">  \t</span></span><br><span class="line"><span class="string">  \n</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p>构造方法允许 <strong>一个主构造方法</strong> 和 <strong>多个二级构造方法</strong> ，每个二级构造函数需要委托给主构造函数，或者通过委托另一个二级构造方法来间接委托</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> <span class="keyword">constructor</span></span>()&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(character:String, appearance:String):<span class="keyword">this</span>()</span><br><span class="line">    <span class="keyword">constructor</span>(character: String, appearance: String, voice: String) : <span class="keyword">this</span>(character, appearance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只有一个构造方法时，<code>constructor()</code> 可以省略</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span></span>(character: String, appearance: String, voice: String)</span><br></pre></td></tr></table></figure></li><li><p>不需要用new关键字</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> aGirl:Girl = Girl(<span class="string">"温柔"</span>,<span class="string">"甜美"</span>,<span class="string">"动人"</span>)</span><br></pre></td></tr></table></figure></li><li><p>可以直接把主构造中的参数直接声明成为类的属性，在参数名前加上 <code>var</code> 或 <code>val</code> ,在创建类的时候，调用构造函数就直接把它们进行了初始化，这样就不用在类中单独声明类的属性了</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>(<span class="keyword">var</span> character: String, appearance: String, voice: String)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">val</span> aGirl:Girl = Girl(<span class="string">"温柔"</span>,<span class="string">"甜美"</span>,<span class="string">"动人"</span>)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">println(aGirl.character) <span class="comment">//right</span></span><br><span class="line">println(aGirl.appearance) <span class="comment">//wrong</span></span><br></pre></td></tr></table></figure></li><li><p><code>init{}</code> 相当于构造方法的方法体</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>(character: String)&#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"new a girl ,she is <span class="variable">$character</span>)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="空类型安全"><a href="#空类型安全" class="headerlink" title="空类型安全"></a>空类型安全</h2><ul><li><p>返回值可为空的方法或者值可为空变量必须加上 <code>?</code> ,否则编译无法通过</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>?.</code> 代表如果不为空就返回后面的值</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(name?.length)</span><br></pre></td></tr></table></figure></li><li><p><code>?:</code> 代表如果为空就返回后面的值</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name = getName() ?: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li><li><p>如果能确定值确实不为空,可以用 <code>!!</code> 声明</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> value: String? = <span class="string">"Hello World"</span></span><br><span class="line">println(value!!.length)</span><br></pre></td></tr></table></figure></li></ul><h2 id="智能类型转换"><a href="#智能类型转换" class="headerlink" title="智能类型转换"></a>智能类型转换</h2><ul><li><p>在已知为子类实例时，不需要像 Java 一样做强转，编译器会尽可能推导类型</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getName() 是 Child 类里的方法</span></span><br><span class="line"><span class="keyword">val</span> parent: Parent = Child()</span><br><span class="line"><span class="keyword">if</span> (parent <span class="keyword">is</span> Child)</span><br><span class="line">    println(parent.name)</span><br></pre></td></tr></table></figure></li><li><p><code>as</code> 后面加上 <code>?</code> ,强制转换失败时返回空，而不会抛异常</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> parent: Parent = Parent()</span><br><span class="line"><span class="keyword">val</span> child: Child? = parent <span class="keyword">as</span>? Child</span><br></pre></td></tr></table></figure></li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li><p>导入类可以指定别名</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.println.kotlin.chapter2.市委.上海.市委书记 <span class="keyword">as</span> 茶水大王</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">val</span> 上海市委书记: 茶水大王 = 茶水大王(<span class="string">"李"</span>)</span><br></pre></td></tr></table></figure></li><li><p>包和路径可以不一致，但是最好不要这样写</p></li></ul><h2 id="区间-Range"><a href="#区间-Range" class="headerlink" title="区间 ( Range )"></a>区间 ( Range )</h2><ul><li>接口 <code>ClosedRange</code> 的子类,  <code>IntRange</code> 最常用</li><li><p>用 <code>..</code> 表示闭区间，用 <code>until</code> 表示半开区间</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> range:IntRange=<span class="number">0.</span><span class="number">.1024</span> <span class="comment">//[0,1024] ..操作符对应 rangeTo()方法</span></span><br><span class="line"><span class="comment">//val range:IntRange= 0.rangeTo(1024)</span></span><br><span class="line"><span class="keyword">val</span> range_exclusive:IntRange=<span class="number">0</span> until <span class="number">1024</span> <span class="comment">//[0,1024)</span></span><br></pre></td></tr></table></figure></li><li><p>用 <code>in</code> 或者 <code>contains()</code> 方法检查元素是否在区间内</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//println(range.contains(40))</span></span><br><span class="line">println(<span class="number">40</span> <span class="keyword">in</span> <span class="number">0.</span><span class="number">.100</span>) <span class="comment">//print true</span></span><br></pre></td></tr></table></figure></li><li><p>用 <code>in</code> 也可以迭代区间</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> range)&#123;</span><br><span class="line">    print(<span class="string">"<span class="variable">$i</span>,"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>基本类型的数组使用 “ 类型名 + ArrayOf “ 系列方法构建，为了减少装箱和拆箱带来的开销</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> arrayOfInt:IntArray = intArrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line"><span class="keyword">val</span> arrayofChar:CharArray = charArrayOf(<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>)</span><br></pre></td></tr></table></figure></li><li><p>其它类型使用 <code>arrayOf()</code></p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> arrayOfString:Array&lt;String&gt; = arrayOf(<span class="string">"我是"</span>,<span class="string">"码农"</span>)</span><br></pre></td></tr></table></figure></li><li><p>基本用法</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//return the array's length</span></span><br><span class="line">println(arrayOfInt.size)</span><br><span class="line"><span class="comment">//foreach</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> arrayOfInt)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use [index] instead of get and set</span></span><br><span class="line">println(arrayOfString[<span class="number">1</span>])</span><br><span class="line">arrayOfString[<span class="number">1</span>] = <span class="string">"程序员"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//use some char insert a CharAarry and to be a String</span></span><br><span class="line"><span class="keyword">val</span> s = arrayofChar.joinToString(<span class="string">""</span>) <span class="comment">//return "Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切片</span></span><br><span class="line">println(arrayOfInt.slice(<span class="number">1.</span><span class="number">.3</span>)) <span class="comment">//return [3,5,7]</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><ul><li><code>val</code> 表示常量, <code>var</code> 表示变量  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = getX() <span class="comment">//运行时常量</span></span><br><span class="line">const x = <span class="string">"..."</span> <span class="comment">//编译期常量</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>无返回值是返回 <code>Unit</code>, 等同于 Java 的 <code>void</code>, 返回类型是 <code>Unit</code> 时, 可以忽略不写</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(arg1: <span class="type">Int</span>, arg2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当函数体只是一个返回一个值的表达式时，可以简化写法：</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//The return type can be omitted</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(arg1: <span class="type">Int</span>, arg2: <span class="type">Int</span>)</span></span> = arg1 + arg2</span><br></pre></td></tr></table></figure></li><li><p>匿名函数，可以赋值给一个变量，除了没有名字，定义和使用和普通函数一样</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//The return type can be omitted</span></span><br><span class="line"><span class="keyword">val</span> intToLong = <span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>)</span></span> = x.toLong()</span><br><span class="line"><span class="comment">//use</span></span><br><span class="line">println(intToLong(<span class="number">4</span>))</span><br></pre></td></tr></table></figure></li></ul><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><ul><li><p>Lambda 表达式其实也是函数的一种，写法是：{[参数列表]-&gt;[函数体，最后一行是返回值]}</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; arg1: <span class="built_in">Int</span>, arg2: <span class="built_in">Int</span> -&gt; arg1 + arg2 &#125;</span><br><span class="line"><span class="keyword">val</span> intToLong = &#123; x: <span class="built_in">Int</span> -&gt; x.toLong() &#125;</span><br></pre></td></tr></table></figure></li><li><p>无参：</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> printlnHello = &#123;</span><br><span class="line">    println(<span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Lambda 表达式的返回值是最后一行的返回值</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//return Int</span></span><br><span class="line"><span class="keyword">val</span> sum = &#123; arg1: <span class="built_in">Int</span>, arg2: <span class="built_in">Int</span> -&gt;</span><br><span class="line">    println(<span class="string">"<span class="variable">$arg1</span> + <span class="variable">$arg2</span> = <span class="subst">$&#123;arg1 + arg2&#125;</span>"</span>)</span><br><span class="line">    arg1 + arg2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变量名加 <code>()</code> 的方式是 <code>invoke()</code> 运算符</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; arg1: <span class="built_in">Int</span>, arg2: <span class="built_in">Int</span> -&gt; arg1 + arg2 &#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">sum.invoke(<span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>forEach</code></p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">args.forEach (&#123; println(it)&#125;)</span><br><span class="line"><span class="comment">//如果最后一个参数是 Lambda 表达式, 花括号可以移到小括号的外面：</span></span><br><span class="line">args.forEach() &#123; println(it) &#125;</span><br><span class="line"><span class="comment">//小括号里什么的都没有，就可以删掉</span></span><br><span class="line">args.forEach &#123; println(it) &#125;</span><br><span class="line"><span class="comment">//println 接收的参数和 forEach 接收的参数相同,引用</span></span><br><span class="line">args.forEach (::println)</span><br></pre></td></tr></table></figure></li><li><p>在 Lambda 表达式中 <code>return</code> 实际上不是中断这段表达式，而是中断它外部的函数</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"The End" 不会被打印，因为 forEach 表达式终止了 main 函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    args.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="string">"q"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"The End"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想在一个 Lamdba 表达式中中止当前这一次循环，可以为表达式加上标签，相当于 continue</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式标签</span></span><br><span class="line">args.forEach <span class="symbol">foreach@</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (it==<span class="string">"q"</span>) <span class="keyword">return</span><span class="symbol">@foreach</span></span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//隐式标签 </span></span><br><span class="line">args.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="string">"q"</span>) <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所有的函数的类型都是来自于 <code>Funtions.kt</code> 文件里的接口，从 <code>Function0</code> 到 <code>Function22</code>, 数字代表参数个数，所以 Kotlin 最多允许有22个参数的函数</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** A function that takes 0 arguments. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function0</span>&lt;<span class="type">out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Invokes the function. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span>: R</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/** A function that takes 22 arguments. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function22</span>&lt;<span class="type">in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, in P18, in P19, in P20, in P21, in P22, out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Invokes the function with the specified arguments. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">P1</span>, p2: <span class="type">P2</span>, p3: <span class="type">P3</span>, p4: <span class="type">P4</span>, p5: <span class="type">P5</span>, p6: <span class="type">P6</span>, p7: <span class="type">P7</span>, p8: <span class="type">P8</span>, p9: <span class="type">P9</span>, p10: <span class="type">P10</span>, p11: <span class="type">P11</span>, p12: <span class="type">P12</span>, p13: <span class="type">P13</span>, p14: <span class="type">P14</span>, p15: <span class="type">P15</span>, p16: <span class="type">P16</span>, p17: <span class="type">P17</span>, p18: <span class="type">P18</span>, p19: <span class="type">P19</span>, p20: <span class="type">P20</span>, p21: <span class="type">P21</span>, p22: <span class="type">P22</span>)</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="类成员-成员方法、成员变量"><a href="#类成员-成员方法、成员变量" class="headerlink" title="类成员 (成员方法、成员变量)"></a>类成员 (成员方法、成员变量)</h2><blockquote><p>属性初始化尽量在构造器中完成<br>无法在构造方法中初始化的，尝试降级为局部变量<br>var 用 lateinit 延迟初始化，val 用 lazy<br>可空类型谨慎用 null 直接初始化</p></blockquote><ul><li>方法就是类内部调用的函数，和函数只是叫法不同</li><li><p>Kotlin 的 getter/setter 默认已实现, (val 常量没有 setter）</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Kotlin 代码 */</span><br><span class="line">class A&#123;</span><br><span class="line">    var b =0</span><br><span class="line">&#125;</span><br><span class="line">/* 对应的 Java 代码 */</span><br><span class="line">public class A &#123;</span><br><span class="line">    private int b=0;</span><br><span class="line"></span><br><span class="line">    public int getB() &#123;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setB(int b) &#123;</span><br><span class="line">        this.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以复写 getter/setter，方法用 <code>field</code> 代替成员变量</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span></span><br><span class="line">       <span class="keyword">get</span>() &#123;</span><br><span class="line">           println(<span class="string">"some one tries to get b"</span>)</span><br><span class="line">           <span class="keyword">return</span> field</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">set</span>(value)&#123;</span><br><span class="line">           println(<span class="string">"some one tries to set b"</span>)</span><br><span class="line">           field = value</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置 getter/setter 的访问权限，注意，get 方法的权限必须和该成员变量的访问权限保持一致,kotlin 中默认是 public 权限，不同于 Java 中默认是包访问权限</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Kotlin 允许成员变量不初始化，用 <code>lateinit</code> 即可，但是要注意使用时必须要初始化该成员，否则程序会崩溃</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> c: String</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> a = A()</span><br><span class="line">a.c = <span class="string">"Hello"</span></span><br><span class="line">println(a.c)</span><br></pre></td></tr></table></figure></li><li><p>对于 val 类型的成员，可以使用委托懒加载，懒加载只有使用该成员时才会初始化</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> e: X <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">"init X"</span>)</span><br><span class="line">        X()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><blockquote><p>运算符本质上是函数,通过对应的具名函数来定义</p></blockquote><ul><li>定义一个操作符  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span>(<span class="keyword">var</span> real:<span class="built_in">Double</span>,<span class="keyword">var</span> imageinary:<span class="built_in">Double</span>)&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other:<span class="type">Complex</span>)</span></span>:Complex&#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(real+ other.real,imageinary + other.imageinary)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other:<span class="type">Int</span>)</span></span>:Complex&#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(real+ other,imageinary)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="variable">$real</span> + <span class="subst">$&#123;imageinary&#125;</span>i"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c1 = Complex(<span class="number">3.0</span>,<span class="number">4.0</span>)</span><br><span class="line">    <span class="keyword">val</span> c2 = Complex(<span class="number">2.0</span>,<span class="number">7.6</span>)</span><br><span class="line"></span><br><span class="line">    println(c1 + c2) <span class="comment">//5.0 + 11.6i</span></span><br><span class="line">    println(c1 + <span class="number">8</span>) <span class="comment">//11.0 + 4.0i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><blockquote><p>只有一个参数，且用 <code>infix</code> 修饰的函数</p></blockquote><ul><li>示例  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">on</span><span class="params">(desk:<span class="type">Desk</span>)</span></span>:<span class="built_in">Boolean</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desk</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (Book() on Desk())&#123;  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分支表达式"><a href="#分支表达式" class="headerlink" title="分支表达式"></a>分支表达式</h3><blockquote><p>返回值是每个分支的最后一句</p></blockquote><ul><li><p>if else 表达式</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> DEBUG = <span class="number">1</span></span><br><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> USER = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mode = <span class="keyword">if</span> (args.isNotEmpty() &amp;&amp; args[<span class="number">0</span>] == <span class="string">"1"</span>) DEBUG <span class="keyword">else</span> USER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>when 表达式,加强版 switch</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">99</span></span><br><span class="line">    <span class="comment">//条件语句</span></span><br><span class="line">    <span class="keyword">when</span> (x) &#123;</span><br><span class="line">        <span class="number">102</span> -&gt; println(<span class="string">"right! <span class="variable">$x</span>"</span>)</span><br><span class="line">        <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span> -&gt; println(<span class="string">"<span class="variable">$x</span> is in 1-100"</span>)</span><br><span class="line">        !<span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span> -&gt; println(<span class="string">"<span class="variable">$x</span> is not in 1-100"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无自变量的 when，可以检查在 when 条件左边想要的任何事</span></span><br><span class="line">    <span class="keyword">val</span> mode =<span class="keyword">when</span>&#123;</span><br><span class="line">        args.isNotEmpty() &amp;&amp; args[<span class="number">0</span>]==<span class="string">"1"</span>-&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(mode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><ul><li><p>for 循环</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(arg <span class="keyword">in</span> args)&#123;</span><br><span class="line">    println(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// args.withIndex() 返回一个迭代器</span></span><br><span class="line"><span class="keyword">for</span>(indexedValue <span class="keyword">in</span> args.withIndex())&#123;</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;indexedValue.value&#125;</span> -&gt; <span class="subst">$&#123;indexedValue.index&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以写成两个参数，是因为Data Class</span></span><br><span class="line"><span class="keyword">for</span>((index,value) <span class="keyword">in</span> args.withIndex())&#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$index</span> -&gt; <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while, do while 语句，与 Java 基本相同，break 跳出，continue 跳过</p></li><li>多层循环嵌套的终止结合标签使用  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Outter@</span><span class="keyword">for</span>(...) &#123;</span><br><span class="line">    <span class="symbol">Inner@</span><span class="keyword">while</span>(i&lt;<span class="number">0</span>) &#123; <span class="keyword">if</span>(...) <span class="keyword">break</span><span class="symbol">@Outter</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常捕获-try-catch-finally"><a href="#异常捕获-try-catch-finally" class="headerlink" title="异常捕获 (try, catch, finally)"></a>异常捕获 (try, catch, finally)</h2><ul><li>try catch 语句也是表达式，可以有返回值.finally先执行，然后再返回结果  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = <span class="keyword">try</span> &#123;</span><br><span class="line">    args[<span class="number">0</span>].toInt()/args[<span class="number">1</span>].toInt()  <span class="comment">// 1 / 0</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (e:Exception)&#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    println(<span class="string">"finish"</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(result)  <span class="comment">// print 0</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h3><blockquote><p>给函数的实参附上形参</p></blockquote><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(arg1: <span class="type">Int</span>, arg2: <span class="type">Int</span>)</span></span> = arg1 + arg2</span><br><span class="line">sum(arg1 = <span class="number">2</span>, arg2 = <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><ul><li><p>变长参数可以当数组一样使用</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(<span class="keyword">vararg</span> args: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (arg <span class="keyword">in</span> args)&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变长参数在 kotlin 中可以不放在最后一位，但是变长参数之后的参数需要使用具名参数</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">(double: <span class="type">Double</span>,<span class="keyword">vararg</span> ints:<span class="type">Int</span>,string: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(double)</span><br><span class="line">    ints.forEach(::print)</span><br><span class="line">    println(<span class="string">"\n<span class="variable">$string</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// * 运算符用于变长参数展开数组，目前只支持数组且不能重载</span></span><br><span class="line"><span class="keyword">val</span> array = intArrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">hello(<span class="number">3.0</span>,*array,string = <span class="string">"kotlin"</span>)</span><br></pre></td></tr></table></figure></li><li><p>有歧义时要用具名参数指定</p></li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><ul><li><p>接口内变量不能初始化,而抽象类内的变量必须初始化</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">interfac B&#123;</span><br><span class="line">    <span class="comment">//相当于生成了一个 getJ 和 setJ 方法</span></span><br><span class="line">    <span class="keyword">var</span> j: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同于 Java，kotlin 的接口的方法可以有默认实现,如果有默认实现，实现类可以不用实现该方法</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j:<span class="built_in">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>类和成员默认都是 <code>public</code> 和 <code>final</code> ，变为可被继承需要用 <code>open</code> 声明，或者是 <code>abstract</code></li><li>继承的成员需要使用 <code>override</code> 关键字</li><li><p><code>by</code> 接口代理，有点曲线救国地支持多继承的意思</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeniorManager</span></span>(<span class="keyword">val</span> driver: Driver,<span class="keyword">val</span> writer: Writer):Driver <span class="keyword">by</span> driver,Writer <span class="keyword">by</span> writer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarDriver</span>:<span class="type">Driver&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"开车"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PPTWriter</span>:<span class="type">Writer&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"写PPT"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Writer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> driver = CarDriver()</span><br><span class="line">    <span class="keyword">val</span> writer = PPTWriter()</span><br><span class="line">    <span class="keyword">val</span> seniorManager = SeniorManager(driver,writer)</span><br><span class="line">    seniorManager.drive()</span><br><span class="line">    seniorManager.write()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承方法名重复问题，可以用 super 加模板的方式调用解决，但是方法的返回类型必须相同</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">x</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">x</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> : <span class="type">B</span>, <span class="type">C &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">x</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            y &gt; <span class="number">0</span> -&gt; y</span><br><span class="line">            y &lt; <span class="number">-100</span> -&gt; <span class="keyword">super</span>&lt;B&gt;.x()</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">super</span>&lt;C&gt;.x()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="类及其成员的可见性"><a href="#类及其成员的可见性" class="headerlink" title="类及其成员的可见性"></a>类及其成员的可见性</h2><ul><li><code>private, protected,internal,public</code></li><li><code>internal</code> 是同一 module 内可见</li></ul><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><ul><li>和 class 其它都一样，只是只有一个实例，相当于直接实现了单例</li><li>在 java 代码中调用 kotlin 的 object 类：  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Kotlin 代码</span></span><br><span class="line"><span class="keyword">object</span> Player&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Player"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Java 代码</span></span><br><span class="line">Player.INSTANCE.printName();</span><br></pre></td></tr></table></figure></li></ul><h2 id="伴生对象与静态成员"><a href="#伴生对象与静态成员" class="headerlink" title="伴生对象与静态成员"></a>伴生对象与静态成员</h2><ul><li>静态成员首先考虑使用包级函数、变量替代</li><li><p>伴生对象内的方法和变量，相当于 Java 中的静态方法和静态变量</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latitude</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> value: <span class="built_in">Double</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">ofDouble</span><span class="params">(double: <span class="type">Double</span>)</span></span>: Latitude &#123;</span><br><span class="line">            <span class="keyword">return</span> Latitude(double)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> TAG: String = <span class="string">"Latitude"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    Latitude.ofDouble(<span class="number">1.1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果要在 Java 中一样调用，需要为伴生对象中的方法加上 <code>@JvmStatic</code> 注解，变量上加 <code>@JvmField</code> ，不加的话，调用方式略有区别：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不加注解</span></span><br><span class="line">Latitude.Companion.ofDouble(<span class="number">1.1</span>);</span><br><span class="line">System.out.println(Latitude.Companion.getTAG());</span><br><span class="line"><span class="comment">//加注解</span></span><br><span class="line">Latitude.ofDouble(<span class="number">1.1</span>);</span><br><span class="line">System.out.println(Latitude.TAG);</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><ul><li>方法签名包含方法名和方法参数列表，不包括返回类型</li><li>方法重载与方法的返回类型无关</li></ul><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><ul><li>默认参数的存在可以代替方法重载，一个最佳实践是，如果一个方法重载不能用默认参数代替，那这个重载很可能有隐藏的问题，所以避免定义关系不大的重载</li><li>在 Java 中调用 Kotlin 里的带默认参数的方法，本身不支持默认参数，需要在方法上加上 <code>@JvmOverloads</code> 注解</li></ul><h2 id="扩展成员"><a href="#扩展成员" class="headerlink" title="扩展成员"></a>扩展成员</h2><ul><li><p>为类添加扩展方法，避免写过多的工具类</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    print(<span class="string">"abc"</span>.multiply(<span class="number">3</span>))</span><br><span class="line">    <span class="comment">//print abcabcabc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">multiply</span><span class="params">(int: <span class="type">Int</span>)</span></span>:String&#123;</span><br><span class="line">    <span class="keyword">val</span> stringBuilder = StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.int)&#123;</span><br><span class="line">        stringBuilder.append(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>操作符扩展</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"abc"</span> * <span class="number">4</span>) <span class="comment">// print abcabcabcabc</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">times</span><span class="params">(int: <span class="type">Int</span>)</span></span>:String&#123;</span><br><span class="line">    <span class="keyword">val</span> stringBuilder = StringBuilder()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until int)&#123;</span><br><span class="line">        stringBuilder.append(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩展方法在java中调用</span></span><br><span class="line">System.out.println(ExtendsKt.times(<span class="string">"abc"</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure></li><li><p>扩展属性, 注意扩展属性不能初始化，类似接口属性</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"abc"</span>.a)</span><br><span class="line">    println(<span class="string">"abc"</span>.b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> String.a: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">var</span> String.b: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123; &#125;</span><br><span class="line">    <span class="keyword">get</span>() = <span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h2><ul><li>定义方法：<br>  <code>val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;</code></li><li>代理者需要实现相应的 setValue/getValue 方法  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegates</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hello <span class="keyword">by</span> X()</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value:String?=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef:<span class="type">Any</span>?,property:<span class="type">KProperty</span>&lt;*&gt;)</span></span>:String &#123;</span><br><span class="line">        <span class="keyword">return</span> value?:<span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?,property: <span class="type">KProperty</span>&lt;*&gt;,value:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        println(<span class="string">"set <span class="subst">$&#123;property.name&#125;</span>: <span class="variable">$value</span>"</span>)</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> delegates = Delegates()</span><br><span class="line">    delegates.hello = <span class="string">"hello"</span> <span class="comment">//print set hello: hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><ul><li><p>dataclass 默认实现了 toString(),hashCode() 等方法</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span></span>(<span class="keyword">val</span> id:<span class="built_in">Int</span>,<span class="keyword">val</span> name:String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> china = Country(<span class="number">0</span>,<span class="string">"China"</span>)</span><br><span class="line">    println(china)</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;china.component1()&#125;</span>,<span class="subst">$&#123;china.component2()&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">val</span>(id,name) = china</span><br><span class="line">    println(<span class="string">"<span class="variable">$id</span>,<span class="variable">$name</span>"</span>)</span><br><span class="line">    <span class="comment">/* print</span></span><br><span class="line"><span class="comment">    Country(id=0, name=China)</span></span><br><span class="line"><span class="comment">    0,China</span></span><br><span class="line"><span class="comment">    0,China</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于 component,不是dataclass独有的,普通的类也可以使用</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentX</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello! we are "</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component3</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component4</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> componentX= ComponentX()</span><br><span class="line">    <span class="keyword">val</span>(a,b,c,d) = componentX</span><br><span class="line">    println(<span class="string">"<span class="variable">$a</span><span class="variable">$b</span><span class="variable">$c</span><span class="variable">$d</span>"</span>)</span><br><span class="line">    <span class="comment">/* print</span></span><br><span class="line"><span class="comment">    Hello! we are 110</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dataclass 没有无参构造器，也不能继承，可以使用 allOpen 和 noArg 插件来去除 final 和添加无参构造方法</p></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li><p>kotlin 中内部类默认是静态内部类，这与 Java 不同，如果要变成非静态，需要加上 inner 关键字</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;</span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inner = Outter().Inner()</span><br><span class="line">    <span class="keyword">val</span> inner1 = Outter.Inner1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非静态内部类引用外部类成员，使用 <code>this@&lt;class name&gt;.&lt;property name&gt;</code> </p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> a:<span class="built_in">Int</span>=<span class="number">5</span></span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="keyword">this</span><span class="symbol">@Outter</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>kotlin 的匿名内部类允许继承和多实现，Java 里不可以</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> onClickListener: OnClickListener? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> view = View()</span><br><span class="line">    <span class="comment">//这里的匿名内部类同时继承了 Outter 类</span></span><br><span class="line">    view.onClickListener = <span class="keyword">object</span>: Outter(),OnClickListener&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名内部类实际上是有名字的</p></li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li>kotlin 的枚举类允许添加构造方法和成员方法，但是枚举和其它成员要求用分号隔开  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">LogLevel</span></span>(<span class="keyword">val</span> id:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    VERBOSE(<span class="number">1</span>),DEBUG(<span class="number">2</span>),INFO(<span class="number">3</span>),WARN(<span class="number">4</span>),ERROR(<span class="number">5</span>),ASSET(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="variable">$name</span>, <span class="variable">$ordinal</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//打印 DEBUG 的索引</span></span><br><span class="line">    println(LogLevel.DEBUG.ordinal)</span><br><span class="line">    <span class="comment">//遍历打印所有的枚举</span></span><br><span class="line">    LogLevel.values().map(::println)</span><br><span class="line">    <span class="comment">//获取实例</span></span><br><span class="line">    LogLevel.valueOf(<span class="string">"WARN"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><ul><li><p>子类可数的类，kotlin1.1之前其子类必须是内部类，1.1之后允许子类定义在类的外部，但是必须在同一文件里</p>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerCmd</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Play</span></span>(<span class="keyword">val</span> url: String, <span class="keyword">val</span> position: <span class="built_in">Long</span> = <span class="number">0</span>) : PlayerCmd()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seek</span></span>(<span class="keyword">val</span> position: <span class="built_in">Long</span>) : PlayerCmd()</span><br><span class="line"><span class="keyword">object</span> Pause : PlayerCmd()</span><br><span class="line"><span class="keyword">object</span> Resume : PlayerCmd()</span><br><span class="line"><span class="keyword">object</span> Stop : PlayerCmd()</span><br></pre></td></tr></table></figure></li><li><p>与枚举不同的是：枚举类的每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-简介&quot;&gt;&lt;a href=&quot;#Kotlin-简介&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 简介&quot;&gt;&lt;/a&gt;Kotlin 简介&lt;/h1&gt;&lt;h2 id=&quot;Kotlin-是什么&quot;&gt;&lt;a href=&quot;#Kotlin-是什么&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 是什么&quot;&gt;&lt;/a&gt;Kotlin 是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Android 官方开发语言，100% 兼容 Java&lt;/li&gt;
&lt;li&gt;Kotlin-Js 前端开发&lt;/li&gt;
&lt;li&gt;Kotlin-Jvm 服务端开发&lt;/li&gt;
&lt;li&gt;Kotlin-Native 本地执行程序
    
    </summary>
    
      <category term="学习" scheme="https://howshea.coding.me/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="https://howshea.coding.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://howshea.coding.me/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 和 Java 的编译期常量</title>
    <link href="https://howshea.coding.me/2017/06/15/Kotlin%E5%92%8CJava%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F/"/>
    <id>https://howshea.coding.me/2017/06/15/Kotlin和Java的编译期常量/</id>
    <published>2017-06-15T08:06:02.000Z</published>
    <updated>2019-06-10T11:33:38.102Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中，声明一个不可修改的常量用关键字 <code>final</code> 即可，例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String HELLO_WORLD = <span class="string">"HelloWorld"</span>;</span><br></pre></td></tr></table></figure></p><p>在 Kotlin 中，则是用 <code>val</code> 来表示常量：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> HELLO_WORLD = <span class="string">"HelloWorld"</span></span><br></pre></td></tr></table></figure></p><p>但是两者有一些不同，在 Java 中声明了 <code>final</code>，则意味这这个常量变成了编译期常量，也就是说，编译过后的字节码，所有引用该常量的地方都会直接替换成值，这样有利于提高代码运行效率。<br>在 Kotlin 中，仅用 <code>val</code> 只意味着这是一个常量，而不是变成了编译器常量，如果想变成编译器常量，则需要额外加上 <code>const</code> 关键字：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">const <span class="keyword">val</span> HELLO_WORLD = <span class="string">"HelloWorld"</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Java 中，声明一个不可修改的常量用关键字 &lt;code&gt;final&lt;/code&gt; 即可，例如：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Kotlin" scheme="https://howshea.coding.me/tags/Kotlin/"/>
    
      <category term="Java" scheme="https://howshea.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 中 Lambda 表达式的典型实践之一</title>
    <link href="https://howshea.coding.me/2017/06/05/kotlin%E4%B8%ADlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%85%B8%E5%9E%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>https://howshea.coding.me/2017/06/05/kotlin中lambda表达式的典型实践/</id>
    <published>2017-06-05T01:40:08.000Z</published>
    <updated>2019-06-10T11:33:38.103Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下使用 Kotlin 的 Lambda 表达式简化 Android 中的 setOnClickListener<br><a id="more"></a></p><h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>在 Android 迟迟不能使用 Java8 的情况下，Kotlin 支持 Lambda 表达式则显得非常有用。<br>Lambda 表达式实际就是匿名函数，但是它仍然属于表达式</p><h1 id="Java-的方式实现-view-点击事件"><a href="#Java-的方式实现-view-点击事件" class="headerlink" title="Java 的方式实现 view 点击事件"></a>Java 的方式实现 view 点击事件</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">view.setOnClickListener(<span class="keyword">new</span> OnClickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    Toast.makeText(</span><br><span class="line">           v.getContext(), </span><br><span class="line">           <span class="string">"Click"</span>, </span><br><span class="line">           Toast.LENGTH_SHORT).</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>老司机都能看懂这一段哈，很简单，接下来把上面的 Java 代码换成 Kotlin</p><h1 id="Kotlin-实现-view-的点击事件"><a href="#Kotlin-实现-view-的点击事件" class="headerlink" title="Kotlin 实现 view 的点击事件"></a>Kotlin 实现 view 的点击事件</h1><h2 id="普通实现方法"><a href="#普通实现方法" class="headerlink" title="普通实现方法"></a>普通实现方法</h2><p>(这里使用了 Kotlin 第三方库 Anko 的 toast 函数)<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">view.setOnClickListener(<span class="keyword">object</span> : View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">       toast(<span class="string">"Click"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>看起来简单了一些，但是实际没省多少事，毕竟用 Java 封装一下 Toast 也能简化一点</p><h2 id="Lambda-实现方法"><a href="#Lambda-实现方法" class="headerlink" title="Lambda 实现方法"></a>Lambda 实现方法</h2><p>在Android Studio 3.0 中，当输入 <code>setOnClickListener()</code> 之后可以看到一个参数的提示，IDE提示允许接收 <code>I:((v:View!)-&gt;Unit)!</code> 这样的一个参数，这就是一个 lambda 表达式，Unit 代表没有返回值，所以上面的代码我们可以写成：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">view.setOnClickListener(&#123;view -&gt; toast(<span class="string">"Click"</span>)&#125;)</span><br></pre></td></tr></table></figure></p><p>另外，Kotlin 允许把函数的最后一个 Lambda 表达式参数移到小括号外，所以上面的语句可以写成：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">view.setOnClickListener()&#123;view -&gt; toast(<span class="string">"Click"</span>)&#125;</span><br></pre></td></tr></table></figure></p><p>不止如此，如果函数只有一个 Lambda 表达式,小括号也可以不写，唯一一个参数也可以省略，这样：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">view.setOnClickListener&#123;toast(<span class="string">"Click"</span>)&#125;</span><br></pre></td></tr></table></figure></p><p>比Java的实现代码短了很多，而且具有一种简洁的美感。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一下使用 Kotlin 的 Lambda 表达式简化 Android 中的 setOnClickListener&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://howshea.coding.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://howshea.coding.me/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>互联网职业分析</title>
    <link href="https://howshea.coding.me/2017/05/27/%E4%BA%92%E8%81%94%E7%BD%91%E8%81%8C%E4%B8%9A%E5%88%86%E6%9E%90/"/>
    <id>https://howshea.coding.me/2017/05/27/互联网职业分析/</id>
    <published>2017-05-26T16:39:10.000Z</published>
    <updated>2019-06-10T11:33:38.103Z</updated>
    
    <content type="html"><![CDATA[<p>今天想起来，来仔细做个互联网的职业分析，天天说互联网，至今还没具体了解过一个完备互联网公司的应该有哪些职业。<br><a id="more"></a></p><h1 id="主要岗位分类"><a href="#主要岗位分类" class="headerlink" title="主要岗位分类"></a>主要岗位分类</h1><p>拉勾网是一个互联网招聘平台，所有从拉勾的主页上看，有<strong>七大主要分类</strong>，分别是：</p><blockquote><p><strong>技术、产品、设计、运营、市场与营销、职能、金融</strong></p></blockquote><p>技术我已经足够了解，这里就把技术分类略过，看看其它六大类的细分：</p><ol><li>产品<br><img src="http://wx4.sinaimg.cn/mw690/8127619agy1ffzw31qm9bj20e9058mxa.jpg"></li><li>运营<br><img src="http://wx2.sinaimg.cn/mw690/8127619agy1ffzw351cpcj20ei0703yt.jpg"></li><li>设计<br><img src="http://wx3.sinaimg.cn/mw690/8127619agy1ffzw383gncj20ek09v3z4.jpg"></li><li>市场与营销<br><img src="http://wx1.sinaimg.cn/mw690/8127619agy1ffzw3av2bjj20em0cx750.jpg"></li><li>职能<br><img src="http://wx3.sinaimg.cn/mw690/8127619agy1ffzw3dn7haj20e7075q37.jpg"></li><li>金融<br><img src="http://wx4.sinaimg.cn/mw690/8127619agy1ffzw4eqykej20dj05vwep.jpg"></li></ol><h1 id="找一下重点"><a href="#找一下重点" class="headerlink" title="找一下重点"></a>找一下重点</h1><p>看起来乱七八糟特别多，先不研究金融和设计，那还剩四个，再去掉职能和市场，还有两类互联网最基础的，产品和运营<br>先看一张图：<br><img src="http://wx1.sinaimg.cn/mw690/8127619agy1ffzzqv8wsnj20dn0arq5j.jpg"><br>可以看到，5-10年，年薪最高的是运营的年薪已经和技术贴近，而初始几年，年薪最高的一直是产品，所以我们可以了解到的是互联网公司最重要的三个环节在于：</p><blockquote><p>技术、运营、产品</p></blockquote><h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><p>都知道产品经理，产品经理的职责应该是什么，<strong>推动项目进展-市场的需求挖掘和分析-战略规划</strong>，一般负责“项目推动”的还不能完全称为产品经理，产品助理比较合适</p><h1 id="运营"><a href="#运营" class="headerlink" title="运营"></a>运营</h1><p>工作内容大多数跟文字相关，拉勾上搜索较多的运营岗是 <strong>“文案策划”</strong>,相关的还有：新媒体运营、内容运营、活动策划、市场策划、新媒体编辑，等等一系列岗位。  </p><p>当然运营的核心不是文案，<strong>“用户运营”</strong> 才是核心，用户运营的职责——我找了张图应该能说明：<br><img src="http://wx4.sinaimg.cn/mw690/8127619agy1ffzzqreqfkj20xs0slwy2.jpg"></p><p><strong><blockquote class="blockquote-center">写不动了…………未完待续</blockquote></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想起来，来仔细做个互联网的职业分析，天天说互联网，至今还没具体了解过一个完备互联网公司的应该有哪些职业。&lt;br&gt;
    
    </summary>
    
      <category term="工作" scheme="https://howshea.coding.me/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="职业" scheme="https://howshea.coding.me/tags/%E8%81%8C%E4%B8%9A/"/>
    
      <category term="互联网" scheme="https://howshea.coding.me/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>咖啡豆和一些碎碎念</title>
    <link href="https://howshea.coding.me/2017/04/24/%E8%81%8A%E8%81%8A%E5%92%96%E5%95%A1%E5%92%8C%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://howshea.coding.me/2017/04/24/聊聊咖啡和一些碎碎念/</id>
    <published>2017-04-23T16:33:00.000Z</published>
    <updated>2019-06-10T11:33:38.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谈谈咖啡豆"><a href="#谈谈咖啡豆" class="headerlink" title="谈谈咖啡豆"></a>谈谈咖啡豆</h3><p>开始每天早上手冲咖啡之后，似乎爱上了喝咖啡以及冲咖啡的过程，冲咖啡是个充满惊喜的过程，只要你不拿着温度计去量水温、不掐着秒表去精确控制时间（好吧我承认我也是会拿着表掐个大约时间的），每天的咖啡口感和味道都是有些差别的，这种感觉就像　《 阿甘正传 》　里的那句著名台词: </p><blockquote><p>“Life is like a box of chocolates, you never konw what you are going to get.”</p></blockquote><a id="more"></a><p>第一次买的咖啡豆是 espresso 口味的咖啡豆，符合人们对咖啡的印象，香、醇、苦，然后喝了很久才知道原来还有咖啡豆是完全没有那种香醇和苦味的，有的豆是花的芬芳香气，有的是明媚的果酸味，所以这次买了一堆不同口味的小包装的咖啡豆。<br><img width="500" height="500" src="http://wx3.sinaimg.cn/mw690/8127619agy1fex2tvxralj22ow2owu10.jpg"><br>今天尝了　[ 巴西黄波旁 YELLOW BOURBON ]，　磨出来的粉是明亮偏黄的棕色，这让我已经觉得很新奇了，喝了觉得更新奇，淡淡的咖啡香味，几乎没有焦味，一点点果酸味，总的来说，呃，就是都很淡，有点像茶。</p><h3 id="One"><a href="#One" class="headerlink" title="One"></a>One</h3><p>出来一个人住之后，买了很多东西，说几个提升生活幸福感的东西吧</p><blockquote><ul><li>地毯：坐在地上看书的感觉真的很好</li><li>蓝牙音箱：前段时间买了一个音质不错的蓝牙音箱，声音很干净</li><li>空气炸锅：解决了我想吃肉的又懒得做荤菜的难题，偶尔也用来烤点鱼丸，比水煮好吃</li><li>小米台灯：可以遥控，终于可以在睡觉前靠在床上看看书然后不用下床就能把灯关了，有时候也会把光线调到最暗最黄，然后安稳睡去。</li></ul></blockquote><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p>看完了 《 断舍离 》 ，学到了不少<strong>生活哲学</strong>，有时间写篇关于这本书感悟吧。</p><p><strong>转眼已经四月底了，真的快毕业了，我会怀念的吧，怀念我的成长，怀念她。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;谈谈咖啡豆&quot;&gt;&lt;a href=&quot;#谈谈咖啡豆&quot; class=&quot;headerlink&quot; title=&quot;谈谈咖啡豆&quot;&gt;&lt;/a&gt;谈谈咖啡豆&lt;/h3&gt;&lt;p&gt;开始每天早上手冲咖啡之后，似乎爱上了喝咖啡以及冲咖啡的过程，冲咖啡是个充满惊喜的过程，只要你不拿着温度计去量水温、不掐着秒表去精确控制时间（好吧我承认我也是会拿着表掐个大约时间的），每天的咖啡口感和味道都是有些差别的，这种感觉就像　《 阿甘正传 》　里的那句著名台词: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Life is like a box of chocolates, you never konw what you are going to get.”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活" scheme="https://howshea.coding.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="个人日记" scheme="https://howshea.coding.me/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
    
      <category term="心情" scheme="https://howshea.coding.me/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 14.04 安装 node.js</title>
    <link href="https://howshea.coding.me/2017/03/16/Ubuntu14-04%E5%AE%89%E8%A3%85node-js/"/>
    <id>https://howshea.coding.me/2017/03/16/Ubuntu14-04安装node-js/</id>
    <published>2017-03-16T14:17:49.000Z</published>
    <updated>2019-06-10T11:33:38.103Z</updated>
    
    <content type="html"><![CDATA[<p>在工作的机器上想装个nodejs新版的，用<code>apt-get install</code>装上的nodejs有问题，摸索了一个靠谱的安装方法，操作起来也比较快。<br><a id="more"></a></p><ol><li>先在 <a href="https://npm.taobao.org/mirrors/node/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/node/</a> 中找个最新版的编译好的压缩包，我下载的是 <code>node-v6.10.0-linux-x64.tar.gz</code></li><li>解压，我直接用图形界面解压了，得到一个文件夹</li><li><p>切进去测试一下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd node-v6.10.0-linux-x64/bin</span><br><span class="line">./node -v</span><br></pre></td></tr></table></figure><p>打印出来版本号，没问题。</p></li><li><p>接下来把这个文件夹里的node和npm设置到全局：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /home/username/下载/node-v6.10.0-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /home/username/下载/node-v6.10.0-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></li><li><p>最后测试一下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>分别打印出来：</p><blockquote><p>v6.10.0<br>3.10.10</p></blockquote></li></ol><p>完成!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在工作的机器上想装个nodejs新版的，用&lt;code&gt;apt-get install&lt;/code&gt;装上的nodejs有问题，摸索了一个靠谱的安装方法，操作起来也比较快。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://howshea.coding.me/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://howshea.coding.me/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ViewPager 和 SwipeRefreshLayout 的滑动冲突</title>
    <link href="https://howshea.coding.me/2016/10/28/ViewPager%E5%92%8CSwipeRefreshLayout%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
    <id>https://howshea.coding.me/2016/10/28/ViewPager和SwipeRefreshLayout的滑动冲突/</id>
    <published>2016-10-28T07:16:49.000Z</published>
    <updated>2019-06-10T11:33:38.103Z</updated>
    
    <content type="html"><![CDATA[<p>如题，当<code>SwipeRefreshLayout</code>包裹<code>ViewPager</code>时，发现ViewPager经常滑不动，容易把上面的刷新的小圈圈拽出来，只有手指在屏幕上向斜上方滑或者水平滑动，才能保持正常，这是一个滑动冲突问题。<br><a id="more"></a></p><h2 id="首先上网查一下别人怎么解决的"><a href="#首先上网查一下别人怎么解决的" class="headerlink" title="首先上网查一下别人怎么解决的"></a>首先上网查一下别人怎么解决的</h2><p>好像都是这个解决方案：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">viewPager.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">              <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                  swipeRefreshLayout.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">              <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                 swipeRefreshLayout.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>嗯，代码看起来很美好，但是运行的时候发现，当下拉的手速比较慢时，刷新不能用了，说明SwipeRefreshLayout没有拦截到事件，然后到ViewPager这儿，就被禁用了。  其实看一下SwipeRefreshLayout的源码就能发现问题：<br>在SwipeRefreshLayout的构造器里有这么一句<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop()</span><br></pre></td></tr></table></figure></p><p>然后在<code>onInterceptTouchEvent()</code>方法中有这么一段：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> yDiff = y - mInitialDownY;</span><br><span class="line">    <span class="keyword">if</span> (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) &#123;</span><br><span class="line">        mInitialMotionY = mInitialDownY + mTouchSlop;</span><br><span class="line">        mIsBeingDragged = <span class="keyword">true</span>;</span><br><span class="line">        mProgress.setAlpha(STARTING_PROGRESS_ALPHA);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>好了，问题如此清晰明了，当我们下拉的时候比较慢，第一次手指在y轴滑动的距离还不够<code>mTouchSlop</code>那么长，所以没有拦截，那viewpager秒秒钟给它禁掉了，因为我们在上面重写了ViewPager的触摸事件，之后yDiff的距离够长了，但是它已经被禁掉啊，然后就会出现只有一个半透明的小球滑下来，然后收上去了，什么也没发生……</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>其实，这个滑动冲突的问题的关键在于，当手指向斜下方滑动时，手指在屏幕上移动的x轴的距离大于y轴的距离，这个时候我们是想让viewpager响应的，那重写SwipeRefreshLayout的<code>onInterceptTouchEvent()</code>方法就好了啊，当滑动X轴的距离大于Y轴的距离就让SwipeRefreshLayout不要拦截事件，完整的代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReformSwipRefreshLayout</span> <span class="keyword">extends</span> <span class="title">SwipeRefreshLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> startY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> startX;</span><br><span class="line">    <span class="comment">// 记录viewPager是否拖拽的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsDraggingFlag;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mTouchSlop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReformSwipRefreshLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                startY = ev.getY();</span><br><span class="line">                startX = ev.getX();</span><br><span class="line">                <span class="comment">// 初始化标记</span></span><br><span class="line">                mIsDraggingFlag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">// 如果子view正在拖拽中，则不拦截</span></span><br><span class="line">                <span class="keyword">if</span>(mIsDraggingFlag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">float</span> endY = ev.getY();</span><br><span class="line">                <span class="keyword">float</span> endX = ev.getX();</span><br><span class="line">                <span class="keyword">float</span> distanceX = Math.abs(endX - startX);</span><br><span class="line">                <span class="keyword">float</span> distanceY = endY - startY;</span><br><span class="line">                <span class="comment">// 如果X轴位移大于Y轴位移或者Y轴位移为负数时，事件交给子View处理</span></span><br><span class="line">                <span class="keyword">if</span>(distanceX &gt; mTouchSlop &amp;&amp; distanceX&gt;distanceY) &#123;</span><br><span class="line">                    mIsDraggingFlag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                <span class="comment">// 初始化标记</span></span><br><span class="line">                mIsDraggingFlag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题，当&lt;code&gt;SwipeRefreshLayout&lt;/code&gt;包裹&lt;code&gt;ViewPager&lt;/code&gt;时，发现ViewPager经常滑不动，容易把上面的刷新的小圈圈拽出来，只有手指在屏幕上向斜上方滑或者水平滑动，才能保持正常，这是一个滑动冲突问题。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://howshea.coding.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SwipeRefreshLayout 配合 RecyclerView 实现瀑布流上拉下拉刷新</title>
    <link href="https://howshea.coding.me/2016/10/17/SwipeRefreshLayout%E9%85%8D%E5%90%88RecyclerView%E5%AE%9E%E7%8E%B0%E4%B8%8A%E6%8B%89%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    <id>https://howshea.coding.me/2016/10/17/SwipeRefreshLayout配合RecyclerView实现上拉下拉刷新/</id>
    <published>2016-10-17T13:36:00.000Z</published>
    <updated>2019-06-10T11:33:38.102Z</updated>
    
    <content type="html"><![CDATA[<p>谷歌良心地推出了SwipeRefreshLayout来实现下拉刷新，然而没有做上拉刷新地功能，所以想要上拉刷新就要自己实现，由于瀑布流是好几列，一时间没有思路，就先在网上查了一下，但是发现别人写的实现RecyclerView的上拉刷新的代码都很繁琐，于是自己研究了一下RecyclerView的一些方法，其实还蛮好实现的。<br><a id="more"></a></p><h2 id="首先是一些基本用法"><a href="#首先是一些基本用法" class="headerlink" title="首先是一些基本用法"></a>首先是一些基本用法</h2><ol><li><p>布局的代码：</p> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.SwipeRefreshLayout</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">"@+id/refresh_layout"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">   &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/recycler_view"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">android.support.v4.widget.SwipeRefreshLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>下拉刷新的实现，很简单，实现<code>SwipeRefreshLayout</code>的方法<code>onRefresh()</code>，记得刷新操作完成之后要关掉刷新的圈圈</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mRefreshLayout.setOnRefreshListener(<span class="keyword">new</span> SwipeRefreshLayout.OnRefreshListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">//这里实现一些网络请求等操作</span></span><br><span class="line">               <span class="comment">//这是关闭刷新，不过最好不要写在这，而是写在异步完成之后的地方</span></span><br><span class="line">mRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li></ol><p>附一张效果图：<br><img src="http://ww2.sinaimg.cn/large/8127619agw1f8vmuw8j9yg20g00sgkjn.gif" alt></p><h2 id="实现RecyclerView的上拉刷新"><a href="#实现RecyclerView的上拉刷新" class="headerlink" title="实现RecyclerView的上拉刷新"></a>实现RecyclerView的上拉刷新</h2><p><code>RecyclerView</code>有个<code>OnScrollListener</code>，其中有两个方法，<code>onScrollStateChanged(···)</code>和<code>onScrolled(···)</code>,分析一下上拉的动作，是手指在屏幕上往上滑到列表结束，停了下来，即滑动的状态发生了改变，所以我们只要实现<code>onScrollStateChanged(···)</code>即可<br>代码如下：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mRecyclerView.addOnScrollListener(<span class="keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//判断滑动状态是否为停止状态</span></span><br><span class="line">                <span class="keyword">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE) &#123;</span><br><span class="line">                    <span class="keyword">int</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span>[] ints = mLayoutManager.findLastVisibleItemPositions(<span class="keyword">null</span>);</span><br><span class="line">                    lastIndex = ints[<span class="number">0</span>] &gt; ints[<span class="number">1</span>] ? ints[<span class="number">0</span>] : ints[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (lastIndex + <span class="number">1</span> == mAdapter.getItemCount()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mRefreshLayout.isRefreshing()) &#123;</span><br><span class="line">                            mRefreshLayout.setRefreshing(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//这个位置写上要实现的业务</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>对于多列的RecyclerView瀑布流，<code>StaggeredGridLayoutManager</code>提供了一个<code>findLastVisibleItemPosition()</code>方法，参数是一个数组，用来存储得到的数据，可为空，空的话就返回一个新的数组，这个数组的长度就是瀑布流的列数，上面的代码以两列为例，数组的第一位是第一列最下面的视图索引值，数组的第二位即是第二列最下面的视图的索引值，接着比较出最大的那个，记得要加一，因为是从0开始数的，然后跟已有的总数比较，如果相等，说明已经拉到底了，这个时候就可以刷新数据了，这个时候把<code>SwipeRefreshLayout</code>的刷新的效果打开，获得更好的交互体验。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谷歌良心地推出了SwipeRefreshLayout来实现下拉刷新，然而没有做上拉刷新地功能，所以想要上拉刷新就要自己实现，由于瀑布流是好几列，一时间没有思路，就先在网上查了一下，但是发现别人写的实现RecyclerView的上拉刷新的代码都很繁琐，于是自己研究了一下RecyclerView的一些方法，其实还蛮好实现的。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://howshea.coding.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>DrawerLayout 和 NavigationView 的使用细节</title>
    <link href="https://howshea.coding.me/2016/10/13/DrawerLayout%E5%92%8CNavigationView%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/"/>
    <id>https://howshea.coding.me/2016/10/13/DrawerLayout和NavigationView的使用细节/</id>
    <published>2016-10-13T03:41:00.000Z</published>
    <updated>2019-06-10T11:33:38.101Z</updated>
    
    <content type="html"><![CDATA[<p>昨天想弄个侧边栏，结果踩了很多坑，<code>DrawerLayout</code>和<code>NavigationView</code>配合可以很容易的实现侧边栏，我也用过不少次了，但是之前都是按照模板来写，没出过什么差错，现在我的想法是用activity来托管fragment，而所有的布局包括<code>Toolbar</code>、<code>DrawerLayout</code>都放在fragment的布局文件里，结果就踩了很多坑。<br><a id="more"></a></p><h2 id="DrawLayout在fragment中使用"><a href="#DrawLayout在fragment中使用" class="headerlink" title="DrawLayout在fragment中使用"></a>DrawLayout在fragment中使用</h2><ol><li><p>写了一个简单的Demo，这是fragment布局文件：</p> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/drawer_layout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:clickable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@color/colorPrimary"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:elevation</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:title</span>=<span class="string">"@string/app_name"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.v7.widget.Toolbar</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/navigation_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"start"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:elevation</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:menu</span>=<span class="string">"@menu/navigation_menu"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在fragment中<code>onCreateView()</code>方法中设置：  </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppCompatActivity activity = (AppCompatActivity) getActivity();</span><br><span class="line">        activity.setSupportActionBar(mToolbar);</span><br><span class="line">        activity.getSupportActionBar().setHomeButtonEnabled(<span class="keyword">true</span>);</span><br><span class="line">        activity.getSupportActionBar().setDisplayShowHomeEnabled(<span class="keyword">true</span>);</span><br><span class="line">        ActionBarDrawerToggle toggle = <span class="keyword">new</span> ActionBarDrawerToggle(activity, mDrawerLayout, </span><br><span class="line">mToolbar, R.string.open, R.string.close);</span><br><span class="line">        toggle.syncState();</span><br><span class="line">        mDrawerLayout.addDrawerListener(toggle);</span><br></pre></td></tr></table></figure></li><li><p>注意几个点：</p><ul><li>drawerlayout的设置要放在fragment的<code>onCreate()</code>之后，否则会报空指针</li><li>NavigationView的<code>layout_gravity</code>属性设置成left的话编译有时候会报错，有时候又正常，不知道为什么，总之设置成start是没有问题的</li></ul></li></ol><h2 id="关于NavigationView"><a href="#关于NavigationView" class="headerlink" title="关于NavigationView"></a>关于NavigationView</h2><ol><li><strong>主界面要显示的内容要包含在DrawerLayout中</strong>，否则会挡住NavigationView的显示</li><li>NavigationView必须是DrawerLayout的次一级的子布局，就是<strong>不能在NavigationView外面在加一层布局</strong></li><li>如果不想让侧边栏遮住Toolbar，DrawerLayout要写在Toolbar的外面</li></ol><h2 id="其它解决方案"><a href="#其它解决方案" class="headerlink" title="其它解决方案"></a>其它解决方案</h2><p>其实完全可以把侧边栏写在Activity中，如果要响应fragment的操作，<strong>可以由fragment丢出一个接口</strong>，这样就可以实现了。<br>不过这样似乎违背了activity只用来托管的想法，还是看项目具体怎么规划</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天想弄个侧边栏，结果踩了很多坑，&lt;code&gt;DrawerLayout&lt;/code&gt;和&lt;code&gt;NavigationView&lt;/code&gt;配合可以很容易的实现侧边栏，我也用过不少次了，但是之前都是按照模板来写，没出过什么差错，现在我的想法是用activity来托管fragment，而所有的布局包括&lt;code&gt;Toolbar&lt;/code&gt;、&lt;code&gt;DrawerLayout&lt;/code&gt;都放在fragment的布局文件里，结果就踩了很多坑。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://howshea.coding.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>重装系统之后 hexo 恢复</title>
    <link href="https://howshea.coding.me/2016/09/05/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%90%8Ehexo%E6%81%A2%E5%A4%8D/"/>
    <id>https://howshea.coding.me/2016/09/05/重装系统之后hexo恢复/</id>
    <published>2016-09-05T11:47:00.000Z</published>
    <updated>2019-06-10T11:33:38.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如果这篇发出去说明hexo已经恢复成功了"><a href="#如果这篇发出去说明hexo已经恢复成功了" class="headerlink" title="如果这篇发出去说明hexo已经恢复成功了"></a>如果这篇发出去说明hexo已经恢复成功了</h1><p>对git很多不熟悉，折腾了一下午</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如果这篇发出去说明hexo已经恢复成功了&quot;&gt;&lt;a href=&quot;#如果这篇发出去说明hexo已经恢复成功了&quot; class=&quot;headerlink&quot; title=&quot;如果这篇发出去说明hexo已经恢复成功了&quot;&gt;&lt;/a&gt;如果这篇发出去说明hexo已经恢复成功了&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="无聊" scheme="https://howshea.coding.me/tags/%E6%97%A0%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>解决 Activity 跳转时动画卡住的问题</title>
    <link href="https://howshea.coding.me/2016/05/15/%E8%A7%A3%E5%86%B3Activity%E8%B7%B3%E8%BD%AC%E6%97%B6%E5%8A%A8%E7%94%BB%E5%8D%A1%E4%BD%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://howshea.coding.me/2016/05/15/解决Activity跳转时动画卡住的问题/</id>
    <published>2016-05-15T05:01:49.000Z</published>
    <updated>2019-06-10T11:33:38.104Z</updated>
    
    <content type="html"><![CDATA[<p>昨天开始着手做一个小项目，一开始就遇到了一个头疼的问题。<br>我在ToolBar的右边添加了一个ImageButton，用来代替三个点的菜单按钮，样子如下图<br><a id="more"></a><br><img src="http://ww4.sinaimg.cn/mw690/8127619agw1f3w0ekmb4sj20xm0eljy2.jpg" alt><br>我为这个小按钮写了一个翻转动画，即点一下旋转180度并弹出popupMenu，其它操作旋转回来。<br>主要代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> R.id.settings:  </span><br><span class="line">   <span class="comment">//先执行一个翻转动画  </span></span><br><span class="line">   animation0.setDuration(<span class="number">200</span>);  </span><br><span class="line">   animation0.setFillAfter(<span class="keyword">true</span>);  </span><br><span class="line">   settings.startAnimation(animation0);  </span><br><span class="line">   PopupMenu popupMenu = <span class="keyword">new</span> PopupMenu(MainActivity.<span class="keyword">this</span>, v);  </span><br><span class="line">   popupMenu.inflate(R.menu.main_menu);  </span><br><span class="line">   popupMenu.setOnMenuItemClickListener(MainActivity.<span class="keyword">this</span>);  </span><br><span class="line">   popupMenu.setOnDismissListener(MainActivity.<span class="keyword">this</span>);  </span><br><span class="line">   popupMenu.show();  </span><br><span class="line">   <span class="keyword">break</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">......  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMenuItemClick</span><span class="params">(MenuItem item)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">switch</span> (item.getItemId()) &#123;  </span><br><span class="line">       <span class="keyword">case</span> R.id.setting:  </span><br><span class="line">            startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, PreferenceActivity.class));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">       <span class="keyword">case</span> R.id.about:  </span><br><span class="line">            ......  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">       <span class="keyword">default</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">......  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDismiss</span><span class="params">(PopupMenu menu)</span> </span>&#123;  </span><br><span class="line">   animation1.setDuration(<span class="number">200</span>);  </span><br><span class="line">   animation1.setFillAfter(<span class="keyword">true</span>);  </span><br><span class="line">   settings.startAnimation(animation1);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在出现的问题是:<br><strong>当我点击menu中的设置跳转到设置界面时，那个按钮的动画会被卡住，等我从设置页面回来，动画还会走完剩下的一半</strong>，所以，特别难看。  </p><p>出现这个问题，无非是动画走到一半就被当前Activiy的<code>onPause()</code>方法打断了，于是我在<code>startActivity()</code>加了一句：  </p><blockquote><p>settings.clearAnimation();  </p></blockquote><p>结果，竟然无效，这就很奇怪了。  </p><p>于是做了一个测试：<br>在<code>onMenuItemClick()</code>,<code>onDismiss()</code>和<code>onPause()</code>中分别加一句：  </p><blockquote><p>System.out.println(“onMenuItemClick”);<br>System.out.println(“onDismiss”);<br>System.out.println(“onPause”);  </p></blockquote><p>运行结果：<br><img src="http://ww4.sinaimg.cn/large/8127619agw1f3w0el8k1lj20ky01m3ys.jpg" alt>  </p><p>这下问题就很清晰了，popupMenu的回调方法是先响应<strong>onMenuItemClick()</strong>,后响应<strong>onDismiss()</strong>,所以不管之前做什么操作，这个动画都会执行，那解决方案也十分明确了，由于<strong>onPause()</strong>是最后才执行，所以重写Activity的<code>onPause()</code>方法即可：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">   settings.clearAnimation();  </span><br><span class="line">   System.out.println(<span class="string">"onPause"</span>);  </span><br><span class="line">   <span class="keyword">super</span>.onPause();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天开始着手做一个小项目，一开始就遇到了一个头疼的问题。&lt;br&gt;我在ToolBar的右边添加了一个ImageButton，用来代替三个点的菜单按钮，样子如下图&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://howshea.coding.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 之性能优化</title>
    <link href="https://howshea.coding.me/2016/04/06/Android-Studio%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://howshea.coding.me/2016/04/06/Android-Studio之性能优化/</id>
    <published>2016-04-06T08:59:00.000Z</published>
    <updated>2019-06-10T11:33:38.101Z</updated>
    
    <content type="html"><![CDATA[<p>为自己的笔记本更换SSD已有一个月的时间，当时换ssd的主要原因是因为Android Studio太卡，然而换上ssd之后，虽然好了很多，但是仍然觉得studio运行得不理想，郁闷呐，好歹我上的也是一块高端ssd。今天上课的时候上知乎查了一下怎么优化，竟然一下子查到了，还是知乎给力啊(奇怪的是我之前也查过，不知道为什么没查到),优化过程如下：<br><a id="more"></a>  </p><h1 id="修改studio-exe-vmoptions和studio64-exe-vmoptions文件"><a href="#修改studio-exe-vmoptions和studio64-exe-vmoptions文件" class="headerlink" title="修改studio.exe.vmoptions和studio64.exe.vmoptions文件"></a><small>修改studio.exe.vmoptions和studio64.exe.vmoptions文件</small></h1><p>在AndroidStudio目录下bin文件夹下找到两个文件<code>studio.exe.vmoptions</code>和<code>studio64.exe.vmoptions</code><br><img src="http://ww3.sinaimg.cn/large/8127619ajw1f2n6gry45pj20hd032t8q.jpg" alt><br>默认的参数分配的内存很少，我的笔记本8G内存，不利用起来是严重的浪费  </p><blockquote><p>-Xms2048m<br>-Xmx2048m<br>-XX:MaxPermSize=2048m<br>-XX:ReservedCodeCacheSize=1024m  </p></blockquote><p>如上，这几个参数都改大一点就行，我改成这样启动速度已经快得飞起，幸福感爆棚了<br>然后再加一行：</p><blockquote><p>-XX:+UseCompressedOops  </p></blockquote><p>这句用于压缩指针空间，可以减少一定的内存占用(64位才支持)  </p><h1 id="修改AndroidStudio设置"><a href="#修改AndroidStudio设置" class="headerlink" title="修改AndroidStudio设置"></a><small>修改AndroidStudio设置</small></h1><p>勾选offline work<br><img src="http://ww4.sinaimg.cn/large/8127619agw1f2n5pcjy2sj20un0jbq3x.jpg" alt>  </p><p>最后，尽量使用新版Android Studio，新版的明显性能更好！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为自己的笔记本更换SSD已有一个月的时间，当时换ssd的主要原因是因为Android Studio太卡，然而换上ssd之后，虽然好了很多，但是仍然觉得studio运行得不理想，郁闷呐，好歹我上的也是一块高端ssd。今天上课的时候上知乎查了一下怎么优化，竟然一下子查到了，还是知乎给力啊(奇怪的是我之前也查过，不知道为什么没查到),优化过程如下：&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://howshea.coding.me/tags/Android/"/>
    
      <category term="Android Studio" scheme="https://howshea.coding.me/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>网站收集</title>
    <link href="https://howshea.coding.me/2016/03/27/%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86/"/>
    <id>https://howshea.coding.me/2016/03/27/网站收集/</id>
    <published>2016-03-27T05:48:43.000Z</published>
    <updated>2019-06-10T11:33:38.104Z</updated>
    
    <content type="html"><![CDATA[<p>把一些收集的网址放到博客上，分享给别人(屁！根本没人看这个博客，方便自己看是真的);</p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a><small>学习资料</small></h1><ul><li><p>台湾国立大学的算法和数据结构的学习网页，由浅入深，全面且易<br><a href="http://www.csie.ntnu.edu.tw/~u91029/" target="_blank" rel="noopener">www.csie.ntnu.edu.tw/~u91029/</a></p></li><li><p>程序猿必修的中文MOOC汇总，国内名校的慕课，计算机基础课程都在这里<br><a href="http://www.mooc.cn/news/2148.html" target="_blank" rel="noopener">www.mooc.cn/news/2148.html</a></p><a id="more"></a>  </li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a><small>工具</small></h1><ul><li><p>日本传统色的配色方案，文艺且好用，不过不翻墙的话加载有点慢，目前windows上只发现Chrome能兼容,不翻墙的话还会少显示一些图标（不过不影响使用）<br><a href="http://nipponcolors.com" target="_blank" rel="noopener">nipponcolors.com</a></p></li><li><p>图标网址<br><a href="http://www.easyicon.net/" target="_blank" rel="noopener">www.easyicon.net</a></p></li><li><p>一个国内的配色网站<br><a href="http://peise.net/" target="_blank" rel="noopener">peise.net</a></p></li></ul><h1 id="Android开发"><a href="#Android开发" class="headerlink" title="Android开发"></a><small>Android开发</small></h1><ul><li><p>Android Studio中文社区，AS和SDK啥的都能下载到<br><a href="http://www.android-studio.org" target="_blank" rel="noopener">www.android-studio.org</a></p></li><li><p>AndroidDevTools,这里整理了各种开发工具与sdk等，不需要翻墙<br><a href="http://www.androiddevtools.cn" target="_blank" rel="noopener">www.androiddevtools.cn</a></p></li><li><p>Material Design调色板，不翻墙加载不全<br><a href="http://www.materialpalette.com/" target="_blank" rel="noopener">www.materialpalette.com</a></p></li><li><p>Google Android官方教程中文版<br><a href="http://t.cn/RvHtswy" target="_blank" rel="noopener">t.cn/RvHtswy</a></p></li></ul><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a><small>Other</small></h1><ul><li>知乎，无数大神，各种干货，上面的网址几乎都是从这个地方找的……<br><a href="http://www.zhihu.com" target="_blank" rel="noopener">www.zhihu.com</a></li><li>github，不上不是程序员<br><a href="http://github.com" target="_blank" rel="noopener">github.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把一些收集的网址放到博客上，分享给别人(屁！根本没人看这个博客，方便自己看是真的);&lt;/p&gt;
&lt;h1 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;headerlink&quot; title=&quot;学习资料&quot;&gt;&lt;/a&gt;&lt;small&gt;学习资料&lt;/small&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;台湾国立大学的算法和数据结构的学习网页，由浅入深，全面且易&lt;br&gt;&lt;a href=&quot;http://www.csie.ntnu.edu.tw/~u91029/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.csie.ntnu.edu.tw/~u91029/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;程序猿必修的中文MOOC汇总，国内名校的慕课，计算机基础课程都在这里&lt;br&gt;&lt;a href=&quot;http://www.mooc.cn/news/2148.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.mooc.cn/news/2148.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://howshea.coding.me/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="资料" scheme="https://howshea.coding.me/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 的优化和配置</title>
    <link href="https://howshea.coding.me/2016/03/06/Hexo%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://howshea.coding.me/2016/03/06/Hexo的优化和配置/</id>
    <published>2016-03-06T13:10:00.000Z</published>
    <updated>2019-06-10T11:33:38.102Z</updated>
    
    <content type="html"><![CDATA[<p><big><b>序：</b></big> 这个博客已经加上了多说评论系统，修改了评论框的css样式，好看了一些；今天在阿里云那里买了.com的域名，折腾了半天终于也弄好了域名解析，嗯……还是想把经验分享一下<br><a id="more"></a></p><h1 id="购买域名以及完成域名解析"><a href="#购买域名以及完成域名解析" class="headerlink" title="购买域名以及完成域名解析"></a><small>购买域名以及完成域名解析</small></h1><ul><li>域名是在<a href="http://wanwang.aliyun.com/" target="_blank" rel="noopener">阿里云万网</a>那里买的，看网上大多数人都推荐在<a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">GoDaddy</a>，我觉得都行吧。买域名的时候注意，有些域名在国内好像不能解析，.cn要备案才能使用，所以选择.com和.org等老牌域名还是比较省心的。  </li><li>域名解析也是用的阿里云万网的免费域名解析服务，这里要注意几点  </li></ul><ol><li>我一开始像一个教程里设置成如下这样，结果没解析成功<br><img src="http://ww4.sinaimg.cn/large/8127619agw1f1nj4qpk9kj20nq031jrc.jpg" alt><br>后来把主机记录设置<code>@</code>、记录类型改成<code>A</code>、记录值改成了我的github pages的ip地址就ok了</li><li>解析前要在仓库里建一个<code>CNAME</code>文件，里面内容是你的域名，这里有个问题，你建了这个文件之后，以后一旦<code>hexo d -g</code>，这个文件就没了，所以还要在hexo文件夹下source下也建个CNAME文件，里面的内容也一样。  </li></ol><h1 id="添加多说评论系统"><a href="#添加多说评论系统" class="headerlink" title="添加多说评论系统"></a><small>添加多说评论系统</small></h1><ul><li>这个没什么难的，在多说网址里设置一下就行，这里分享一下自定义css样式，因为默认的实在太丑  </li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-tag">ul</span><span class="selector-class">.ds-comments-tabs</span> <span class="selector-tag">li</span><span class="selector-class">.ds-tab</span> <span class="selector-tag">a</span><span class="selector-class">.ds-current</span> &#123;<span class="attribute">border</span>:<span class="number">0px</span>;<span class="attribute">color</span>:<span class="number">#848568</span>;<span class="attribute">text-shadow</span>:none;<span class="attribute">background</span>:<span class="number">#dddfc2</span>&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-highlight</span> &#123;<span class="attribute">font-family</span>:Arial, Helvetica, sans-serif;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">font-weight</span>:bold;<span class="attribute">color</span>:<span class="number">#848568</span> <span class="meta">!important</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-tag">ul</span><span class="selector-class">.ds-comments-tabs</span> <span class="selector-tag">li</span><span class="selector-class">.ds-tab</span> <span class="selector-tag">a</span><span class="selector-class">.ds-current</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#696a52</span>;<span class="attribute">background</span>:<span class="number">#d4d6ba</span>&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-tag">a</span><span class="selector-class">.ds-highlight</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#696a52</span> <span class="meta">!important</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-thread</span> &#123;<span class="attribute">padding-left</span>:<span class="number">30px</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-tag">li</span><span class="selector-class">.ds-post</span>,<span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-hot-posts</span> &#123;<span class="attribute">overflow</span>:visible&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-post-self</span> &#123;<span class="attribute">padding</span>:<span class="number">10px</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">10px</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-tag">li</span><span class="selector-class">.ds-post</span>,<span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-post-self</span> &#123;<span class="attribute">border</span>:<span class="number">0</span> <span class="meta">!important</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-avatar</span>, <span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-tag">ul</span><span class="selector-class">.ds-children</span> <span class="selector-class">.ds-avatar</span> &#123;<span class="attribute">position</span>:absolute;<span class="attribute">top</span>:<span class="number">26px</span>;<span class="attribute">left</span>:-<span class="number">14px</span>;<span class="attribute">padding</span>:<span class="number">5px</span>;<span class="attribute">width</span>:<span class="number">36px</span>;<span class="attribute">height</span>:<span class="number">36px</span>;<span class="attribute">box-shadow</span>:-<span class="number">1px</span> <span class="number">0</span> <span class="number">1px</span> <span class="built_in">rgba</span>(0,0,0,.15) inset;<span class="attribute">border-radius</span>:<span class="number">46px</span>; <span class="attribute">background</span>:<span class="number">#E5E6D0</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-tag">ul</span><span class="selector-class">.ds-children</span> <span class="selector-class">.ds-avatar</span> &#123;<span class="attribute">left</span>:-<span class="number">23px</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-class">.ds-avatar</span> <span class="selector-tag">a</span> &#123;<span class="attribute">display</span>:inline-block;<span class="attribute">padding</span>:<span class="number">1px</span>; <span class="attribute">width</span>:<span class="number">32px</span>;<span class="attribute">height</span>:<span class="number">32px</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#b9baa6</span>;<span class="attribute">border-radius</span>:<span class="number">50%</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span> <span class="meta">!important</span>&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-class">.ds-avatar</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">border-color</span>:<span class="number">#de5a4e</span>&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-class">.ds-avatar</span> &gt; <span class="selector-tag">img</span> &#123;<span class="attribute">margin</span>:<span class="number">2px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span>&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-replybox</span> &#123;<span class="attribute">box-shadow</span>:none;&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-tag">ul</span><span class="selector-class">.ds-children</span> <span class="selector-class">.ds-replybox</span><span class="selector-class">.ds-inline-replybox</span> <span class="selector-tag">a</span><span class="selector-class">.ds-avatar</span>,</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-replybox</span><span class="selector-class">.ds-inline-replybox</span> <span class="selector-tag">a</span><span class="selector-class">.ds-avatar</span> &#123;<span class="attribute">left</span>: <span class="number">0</span>;<span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>;<span class="attribute">width</span>: <span class="number">32px</span> <span class="meta">!important</span>;<span class="attribute">height</span>: <span class="number">32px</span> <span class="meta">!important</span>; <span class="attribute">background</span>: none;<span class="attribute">box-shadow</span>: none; &#125; </span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-replybox</span><span class="selector-class">.ds-inline-replybox</span> <span class="selector-tag">a</span><span class="selector-class">.ds-avatar</span> <span class="selector-tag">img</span> &#123;<span class="attribute">width</span>: <span class="number">32px</span> <span class="meta">!important</span>;<span class="attribute">height</span>: <span class="number">32px</span> <span class="meta">!important</span>; <span class="attribute">border-radius</span>:<span class="number">50%</span>;&#125; </span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-replybox</span> <span class="selector-tag">a</span><span class="selector-class">.ds-avatar</span>,</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-replybox</span> <span class="selector-class">.ds-avatar</span> <span class="selector-tag">img</span> &#123; <span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">width</span>:<span class="number">50px</span> <span class="meta">!important</span>;<span class="attribute">height</span>:<span class="number">50px</span> <span class="meta">!important</span>; <span class="attribute">border-radius</span>:<span class="number">5px</span>; &#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-avatar</span> <span class="selector-tag">img</span> &#123;<span class="attribute">width</span>:<span class="number">32px</span> <span class="meta">!important</span>;<span class="attribute">height</span>:<span class="number">32px</span> <span class="meta">!important</span>;<span class="attribute">border-radius</span>:<span class="number">32px</span>;<span class="attribute">box-shadow</span>:<span class="number">0</span> <span class="number">1px</span> <span class="number">3px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.22);</span><br><span class="line"><span class="attribute">-webkit-transition</span>:.<span class="number">4s</span> all ease-in-out;<span class="attribute">-moz-transition</span>:.<span class="number">4s</span> all ease-in-out;<span class="attribute">-o-transition</span>:.<span class="number">4s</span> all ease-in-out;<span class="attribute">-ms-transition</span>:.<span class="number">4s</span> all ease-in-out;<span class="attribute">transition</span>:.<span class="number">4s</span> all ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ds-post-self</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.ds-avatar</span> <span class="selector-tag">img</span> &#123;<span class="attribute">-webkit-transform</span>:<span class="built_in">rotate</span>(360deg);<span class="attribute">-moz-transform</span>:<span class="built_in">rotate</span>(360deg);<span class="attribute">-o-transform</span>:<span class="built_in">rotate</span>(360deg);<span class="attribute">-ms-transform</span>:<span class="built_in">rotate</span>(360deg);<span class="attribute">transform</span>:<span class="built_in">rotate</span>(360deg);&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-comment-body</span> &#123;<span class="attribute">background</span>: <span class="number">#F2F2F2</span>;<span class="attribute">padding</span>:<span class="number">15px</span> <span class="number">15px</span> <span class="number">12px</span> <span class="number">32px</span>;<span class="attribute">border-radius</span>:<span class="number">5px</span>; <span class="attribute">box-shadow</span>:<span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(0,0,0,.15), <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="built_in">rgba</span>(255,255,255,.75) inset;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-comment-body</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:<span class="number">#787D7B</span>&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-comments</span> <span class="selector-tag">a</span><span class="selector-class">.ds-user-name</span> &#123;<span class="attribute">font-weight</span>:bold;<span class="attribute">color</span>:<span class="number">#696A52</span> <span class="meta">!important</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-comments</span> <span class="selector-tag">a</span><span class="selector-class">.ds-user-name</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#D32</span> <span class="meta">!important</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-thread</span> <span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-hot-posts</span> &#123;<span class="attribute">border</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-hot-posts</span> <span class="selector-class">.ds-gradient-bg</span> &#123;<span class="attribute">background</span>:none;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-bubble</span> <span class="selector-id">#ds-ctx</span> <span class="selector-class">.ds-ctx-entry</span> &#123;<span class="attribute">padding</span>:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-bubble</span> <span class="selector-class">.ds-avatar</span>, <span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-bubble</span> <span class="selector-id">#ds-ctx-bubble</span> <span class="selector-class">.ds-avatar</span> <span class="selector-tag">a</span> &#123;<span class="attribute">position</span>:static;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">border</span>:<span class="number">0</span>; <span class="attribute">background</span>:none;<span class="attribute">box-shadow</span>:none;&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-bubble</span> <span class="selector-class">.ds-avatar</span> <span class="selector-tag">img</span>, <span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-bubble</span> <span class="selector-id">#ds-ctx-bubble</span> <span class="selector-class">.ds-avatar</span> <span class="selector-tag">a</span> &#123;<span class="attribute">width</span>:<span class="number">45px</span> <span class="meta">!important</span>;<span class="attribute">height</span>:<span class="number">45px</span> <span class="meta">!important</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-bubble</span> <span class="selector-class">.ds-user-name</span>&#123;<span class="attribute">padding-left</span>:<span class="number">13px</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-class">.ds-comment-body</span> <span class="selector-id">#ds-ctx</span> &#123;<span class="attribute">border-left</span>:<span class="number">1px</span> solid <span class="number">#b9baa6</span>;<span class="attribute">background-color</span>:<span class="number">#e8e8dc</span> <span class="meta">!important</span>&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-ctx</span> &#123;<span class="attribute">margin-right</span>:-<span class="number">15px</span>&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-ctx</span> <span class="selector-class">.ds-ctx-entry</span> &#123;<span class="attribute">position</span>:relative;<span class="attribute">padding</span>:<span class="number">10px</span> <span class="number">30px</span> <span class="number">10px</span> <span class="number">10px</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-ctx</span> <span class="selector-class">.ds-ctx-entry</span> <span class="selector-class">.ds-avatar</span> &#123;<span class="attribute">top</span>:<span class="number">6px</span>;<span class="attribute">left</span>:<span class="number">5px</span>;<span class="attribute">background</span>:none;<span class="attribute">box-shadow</span>:none;&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-ctx</span> <span class="selector-class">.ds-ctx-entry</span> <span class="selector-class">.ds-ctx-body</span> &#123;<span class="attribute">margin-left</span>:<span class="number">46px</span>;&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-ctx</span> <span class="selector-class">.ds-ctx-entry</span> <span class="selector-class">.ds-ctx-content</span> &#123;<span class="attribute">color</span>:<span class="number">#787968</span>&#125;</span><br><span class="line"><span class="selector-id">#ds-reset</span> <span class="selector-id">#ds-ctx</span> <span class="selector-class">.ds-ctx-entry</span> <span class="selector-class">.ds-ctx-head</span> <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>:<span class="number">#696A52</span>;<span class="attribute">font-weight</span>:bold&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;big&gt;&lt;b&gt;序：&lt;/b&gt;&lt;/big&gt; 这个博客已经加上了多说评论系统，修改了评论框的css样式，好看了一些；今天在阿里云那里买了.com的域名，折腾了半天终于也弄好了域名解析，嗯……还是想把经验分享一下&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://howshea.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hexo" scheme="https://howshea.coding.me/tags/hexo/"/>
    
      <category term="域名解析" scheme="https://howshea.coding.me/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
